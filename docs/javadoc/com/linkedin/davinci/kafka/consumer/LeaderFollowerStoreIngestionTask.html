<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>LeaderFollowerStoreIngestionTask (venice API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../../jquery/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="../../../../../jquery/jquery-ui.min.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="LeaderFollowerStoreIngestionTask (venice API)";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":10,"i2":9,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10,"i28":10,"i29":10,"i30":10,"i31":10,"i32":10,"i33":10,"i34":10,"i35":10,"i36":10,"i37":10,"i38":10,"i39":10,"i40":10,"i41":10,"i42":10,"i43":10,"i44":10,"i45":10,"i46":10,"i47":10,"i48":10,"i49":10,"i50":10,"i51":10,"i52":10,"i53":10,"i54":10,"i55":10,"i56":10,"i57":10,"i58":10,"i59":10,"i60":10,"i61":10,"i62":10,"i63":10,"i64":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">com.linkedin.davinci.kafka.consumer</a></div>
<h2 title="Class LeaderFollowerStoreIngestionTask" class="title">Class LeaderFollowerStoreIngestionTask</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">com.linkedin.davinci.kafka.consumer.StoreIngestionTask</a></li>
<li>
<ul class="inheritance">
<li>com.linkedin.davinci.kafka.consumer.LeaderFollowerStoreIngestionTask</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><code>java.io.Closeable</code>, <code>java.lang.AutoCloseable</code>, <code>java.lang.Runnable</code></dd>
</dl>
<dl>
<dt>Direct Known Subclasses:</dt>
<dd><code><a href="ActiveActiveStoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">ActiveActiveStoreIngestionTask</a></code></dd>
</dl>
<hr>
<pre>public class <span class="typeNameLabel">LeaderFollowerStoreIngestionTask</span>
extends <a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></pre>
<div class="block">This class contains the state transition work between leader and follower; both leader and follower
 will keep track of information like which topic leader is consuming from and the corresponding offset
 as well as the latest successfully consumed or produced offset in the version topic (VT).

 State Transition:
     1. OFFLINE -> STANDBY:
        Generate a SUBSCRIBE message in the consumer action queue; the logic
        here is the same as Online/Offline model; all it needs to do is to
        restore the checkpointed state from OffsetRecord;
     2. STANDBY -> LEADER:
        The partition will be marked as in the transition progress from STANDBY
        to LEADER and completes the action immediately; after processing the rest
        of the consumer actions in the queue, check whether there is any partition
        is in the transition progress, if so:
        (i)   consume the latest messages from version topic;
        (ii)  drain all the messages in drainer queue in order to update the latest
              consumed message replication metadata;
        (iii) check whether there has been at least 5 minutes (configurable) of
              inactivity for this partition (meaning no new messages); if so,
              turn on the LEADER flag for this partition.
     3. LEADER -> STANDBY:
        a. if the leader is consuming from VT, just set "isLeader" field to
           false and resume consumption;
        b. if the leader is consuming from anything other than VT, it needs to
           unsubscribe from the leader topic for this partition first, drain
           all the messages in the drainer queue for this leader topic/partition
           so that it can get the last producer callback for the last message it
           produces to VT; block on getting the result from the callback to
           update the corresponding offset in version topic, so that the new
           follower can subscribe back to VT using the recently updated VT offset.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<ul class="blockList">
<li class="blockList"><a id="nested.classes.inherited.from.class.com.linkedin.davinci.kafka.consumer.StoreIngestionTask">
<!--   -->
</a>
<h3>Nested classes/interfaces inherited from class&nbsp;com.linkedin.davinci.kafka.consumer.<a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></h3>
<code><a href="StoreIngestionTask.DelegateConsumerRecordResult.html" title="enum in com.linkedin.davinci.kafka.consumer">StoreIngestionTask.DelegateConsumerRecordResult</a></code></li>
</ul>
</li>
</ul>
</section>
<!-- =========== FIELD SUMMARY =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Field</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected it.unimi.dsi.fastutil.ints.Int2ObjectMap&lt;java.lang.String&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#kafkaClusterIdToUrlMap">kafkaClusterIdToUrlMap</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.util.function.Predicate&lt;? super <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#LEADER_OFFSET_LAG_FILTER">LEADER_OFFSET_LAG_FILTER</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../../../venice/serialization/AvroStoreDeserializerCache.html" title="class in com.linkedin.venice.serialization">AvroStoreDeserializerCache</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#storeDeserializerCache">storeDeserializerCache</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected static java.util.function.LongPredicate</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#VALID_LAG">VALID_LAG</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../../../venice/utils/lazy/Lazy.html" title="interface in com.linkedin.venice.utils.lazy">Lazy</a>&lt;<a href="../../../venice/writer/VeniceWriter.html" title="class in com.linkedin.venice.writer">VeniceWriter</a>&lt;byte[],&#8203;byte[],&#8203;byte[]&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#veniceWriter">veniceWriter</a></span></code></th>
<td class="colLast">
<div class="block">N.B.:
    With L/F+native replication and many Leader partitions getting assigned to a single SN this <a href="../../../venice/writer/VeniceWriter.html" title="class in com.linkedin.venice.writer"><code>VeniceWriter</code></a>
    may be called from multiple thread simultaneously, during start of batch push.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected java.util.Map&lt;java.lang.String,&#8203;<a href="../../store/view/VeniceViewWriter.html" title="class in com.linkedin.davinci.store.view">VeniceViewWriter</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#viewWriters">viewWriters</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="fields.inherited.from.class.com.linkedin.davinci.kafka.consumer.StoreIngestionTask">
<!--   -->
</a>
<h3>Fields inherited from class&nbsp;com.linkedin.davinci.kafka.consumer.<a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></h3>
<code><a href="StoreIngestionTask.html#aggKafkaConsumerService">aggKafkaConsumerService</a>, <a href="StoreIngestionTask.html#amplificationFactor">amplificationFactor</a>, <a href="StoreIngestionTask.html#amplificationFactorAdapter">amplificationFactorAdapter</a>, <a href="StoreIngestionTask.html#availableSchemaIds">availableSchemaIds</a>, <a href="StoreIngestionTask.html#bootstrapTimeoutInMs">bootstrapTimeoutInMs</a>, <a href="StoreIngestionTask.html#chunkAssembler">chunkAssembler</a>, <a href="StoreIngestionTask.html#compressionStrategy">compressionStrategy</a>, <a href="StoreIngestionTask.html#compressor">compressor</a>, <a href="StoreIngestionTask.html#compressorFactory">compressorFactory</a>, <a href="StoreIngestionTask.html#consumerActionSequenceNumber">consumerActionSequenceNumber</a>, <a href="StoreIngestionTask.html#consumerActionsQueue">consumerActionsQueue</a>, <a href="StoreIngestionTask.html#databaseSyncBytesIntervalForDeferredWriteMode">databaseSyncBytesIntervalForDeferredWriteMode</a>, <a href="StoreIngestionTask.html#databaseSyncBytesIntervalForTransactionalMode">databaseSyncBytesIntervalForTransactionalMode</a>, <a href="StoreIngestionTask.html#dataRecoverySourceVersionNumber">dataRecoverySourceVersionNumber</a>, <a href="StoreIngestionTask.html#defaultReadyToServeChecker">defaultReadyToServeChecker</a>, <a href="StoreIngestionTask.html#deserializedSchemaIds">deserializedSchemaIds</a>, <a href="StoreIngestionTask.html#diskUsage">diskUsage</a>, <a href="StoreIngestionTask.html#divErrorMetricCallback">divErrorMetricCallback</a>, <a href="StoreIngestionTask.html#emitMetrics">emitMetrics</a>, <a href="StoreIngestionTask.html#emptyPollSleepMs">emptyPollSleepMs</a>, <a href="StoreIngestionTask.html#errorPartitionId">errorPartitionId</a>, <a href="StoreIngestionTask.html#hostLevelIngestionStats">hostLevelIngestionStats</a>, <a href="StoreIngestionTask.html#hybridStoreConfig">hybridStoreConfig</a>, <a href="StoreIngestionTask.html#idleCounter">idleCounter</a>, <a href="StoreIngestionTask.html#ingestionTaskName">ingestionTaskName</a>, <a href="StoreIngestionTask.html#isChunked">isChunked</a>, <a href="StoreIngestionTask.html#isCurrentVersion">isCurrentVersion</a>, <a href="StoreIngestionTask.html#isDataRecovery">isDataRecovery</a>, <a href="StoreIngestionTask.html#isDaVinciClient">isDaVinciClient</a>, <a href="StoreIngestionTask.html#isIsolatedIngestion">isIsolatedIngestion</a>, <a href="StoreIngestionTask.html#isRunning">isRunning</a>, <a href="StoreIngestionTask.html#isWriteComputationEnabled">isWriteComputationEnabled</a>, <a href="StoreIngestionTask.html#kafkaClusterUrlResolver">kafkaClusterUrlResolver</a>, <a href="StoreIngestionTask.html#kafkaProps">kafkaProps</a>, <a href="StoreIngestionTask.html#kafkaVersionTopic">kafkaVersionTopic</a>, <a href="StoreIngestionTask.html#KILL_WAIT_TIME_MS">KILL_WAIT_TIME_MS</a>, <a href="StoreIngestionTask.html#localKafkaClusterId">localKafkaClusterId</a>, <a href="StoreIngestionTask.html#localKafkaServer">localKafkaServer</a>, <a href="StoreIngestionTask.html#localKafkaServerSingletonSet">localKafkaServerSingletonSet</a>, <a href="StoreIngestionTask.html#metaStoreWriter">metaStoreWriter</a>, <a href="StoreIngestionTask.html#partitionConsumptionStateMap">partitionConsumptionStateMap</a>, <a href="StoreIngestionTask.html#partitionToPendingConsumerActionCountMap">partitionToPendingConsumerActionCountMap</a>, <a href="StoreIngestionTask.html#pubSubTopicRepository">pubSubTopicRepository</a>, <a href="StoreIngestionTask.html#readCycleDelayMs">readCycleDelayMs</a>, <a href="StoreIngestionTask.html#readOnlyForBatchOnlyStoreEnabled">readOnlyForBatchOnlyStoreEnabled</a>, <a href="StoreIngestionTask.html#realTimeTopic">realTimeTopic</a>, <a href="StoreIngestionTask.html#recordLevelMetricEnabled">recordLevelMetricEnabled</a>, <a href="StoreIngestionTask.html#REDUNDANT_LOGGING_FILTER">REDUNDANT_LOGGING_FILTER</a>, <a href="StoreIngestionTask.html#SCHEMA_POLLING_DELAY_MS">SCHEMA_POLLING_DELAY_MS</a>, <a href="StoreIngestionTask.html#schemaRepository">schemaRepository</a>, <a href="StoreIngestionTask.html#serverConfig">serverConfig</a>, <a href="StoreIngestionTask.html#statusReportAdapter">statusReportAdapter</a>, <a href="StoreIngestionTask.html#storageEngine">storageEngine</a>, <a href="StoreIngestionTask.html#storageEngineRepository">storageEngineRepository</a>, <a href="StoreIngestionTask.html#storageMetadataService">storageMetadataService</a>, <a href="StoreIngestionTask.html#STORE_VERSION_POLLING_DELAY_MS">STORE_VERSION_POLLING_DELAY_MS</a>, <a href="StoreIngestionTask.html#storeBufferService">storeBufferService</a>, <a href="StoreIngestionTask.html#storeName">storeName</a>, <a href="StoreIngestionTask.html#storeRepository">storeRepository</a>, <a href="StoreIngestionTask.html#storeVersionPartitionCount">storeVersionPartitionCount</a>, <a href="StoreIngestionTask.html#subPartitionCount">subPartitionCount</a>, <a href="StoreIngestionTask.html#topicManagerRepository">topicManagerRepository</a>, <a href="StoreIngestionTask.html#venicePartitioner">venicePartitioner</a>, <a href="StoreIngestionTask.html#versionedDIVStats">versionedDIVStats</a>, <a href="StoreIngestionTask.html#versionedIngestionStats">versionedIngestionStats</a>, <a href="StoreIngestionTask.html#versionNumber">versionNumber</a>, <a href="StoreIngestionTask.html#versionTopic">versionTopic</a>, <a href="StoreIngestionTask.html#writeComputeFailureCode">writeComputeFailureCode</a></code></li>
</ul>
</li>
</ul>
</section>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(com.linkedin.davinci.kafka.consumer.StoreIngestionTaskFactory.Builder,com.linkedin.venice.meta.Store,com.linkedin.venice.meta.Version,java.util.Properties,java.util.function.BooleanSupplier,com.linkedin.davinci.config.VeniceStoreVersionConfig,int,boolean,java.util.Optional,java.util.function.Function)">LeaderFollowerStoreIngestionTask</a></span>&#8203;(<a href="StoreIngestionTaskFactory.Builder.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTaskFactory.Builder</a>&nbsp;builder,
                                <a href="../../../venice/meta/Store.html" title="interface in com.linkedin.venice.meta">Store</a>&nbsp;store,
                                <a href="../../../venice/meta/Version.html" title="interface in com.linkedin.venice.meta">Version</a>&nbsp;version,
                                java.util.Properties&nbsp;kafkaConsumerProperties,
                                java.util.function.BooleanSupplier&nbsp;isCurrentVersion,
                                <a href="../../config/VeniceStoreVersionConfig.html" title="class in com.linkedin.davinci.config">VeniceStoreVersionConfig</a>&nbsp;storeConfig,
                                int&nbsp;errorPartitionId,
                                boolean&nbsp;isIsolatedIngestion,
                                java.util.Optional&lt;<a href="../../store/cache/backend/ObjectCacheBackend.html" title="class in com.linkedin.davinci.store.cache.backend">ObjectCacheBackend</a>&gt;&nbsp;cacheBackend,
                                java.util.function.Function&lt;java.lang.Integer,&#8203;<a href="../../client/DaVinciRecordTransformer.html" title="class in com.linkedin.davinci.client">DaVinciRecordTransformer</a>&gt;&nbsp;getRecordTransformer)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#addPartitionConsumptionState(java.lang.Integer,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">addPartitionConsumptionState</a></span>&#8203;(java.lang.Integer&nbsp;partition,
                            <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;pcs)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>protected java.util.Map&lt;java.lang.String,&#8203;java.lang.Long&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#calculateLeaderUpstreamOffsetWithTopicSwitch(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,com.linkedin.venice.kafka.protocol.TopicSwitch,com.linkedin.venice.pubsub.api.PubSubTopic,java.util.List)">calculateLeaderUpstreamOffsetWithTopicSwitch</a></span>&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState,
                                            <a href="../../../venice/kafka/protocol/TopicSwitch.html" title="class in com.linkedin.venice.kafka.protocol">TopicSwitch</a>&nbsp;topicSwitch,
                                            <a href="../../../venice/pubsub/api/PubSubTopic.html" title="interface in com.linkedin.venice.pubsub.api">PubSubTopic</a>&nbsp;newSourceTopic,
                                            java.util.List&lt;java.lang.CharSequence&gt;&nbsp;unreachableBrokerList)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>protected static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#checkAndHandleUpstreamOffsetRewind(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,com.linkedin.venice.pubsub.api.PubSubMessage,long,long,com.linkedin.davinci.kafka.consumer.LeaderFollowerStoreIngestionTask)">checkAndHandleUpstreamOffsetRewind</a></span>&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState,
                                  <a href="../../../venice/pubsub/api/PubSubMessage.html" title="interface in com.linkedin.venice.pubsub.api">PubSubMessage</a>&lt;<a href="../../../venice/message/KafkaKey.html" title="class in com.linkedin.venice.message">KafkaKey</a>,&#8203;<a href="../../../venice/kafka/protocol/KafkaMessageEnvelope.html" title="class in com.linkedin.venice.kafka.protocol">KafkaMessageEnvelope</a>,&#8203;java.lang.Long&gt;&nbsp;consumerRecord,
                                  long&nbsp;newUpstreamOffset,
                                  long&nbsp;previousUpstreamOffset,
                                  <a href="LeaderFollowerStoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">LeaderFollowerStoreIngestionTask</a>&nbsp;ingestionTask)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#checkAndLogIfLagIsAcceptableForHybridStore(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,long,long,boolean,com.linkedin.davinci.ingestion.LagType,long)">checkAndLogIfLagIsAcceptableForHybridStore</a></span>&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;pcs,
                                          long&nbsp;lag,
                                          long&nbsp;threshold,
                                          boolean&nbsp;shouldLogLag,
                                          <a href="../../ingestion/LagType.html" title="enum in com.linkedin.davinci.ingestion">LagType</a>&nbsp;lagType,
                                          long&nbsp;latestConsumedProducerTimestamp)</code></th>
<td class="colLast">
<div class="block">Checks whether the lag is acceptable for hybrid stores</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#checkLongRunningTaskState()">checkLongRunningTaskState</a></span>()</code></th>
<td class="colLast">
<div class="block">The following function will be executed after processing all the quick actions in the consumer action queues,
 so that the long running actions doesn't block other partition's consumer actions.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#closeVeniceViewWriters()">closeVeniceViewWriters</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#closeVeniceWriters(boolean)">closeVeniceWriters</a></span>&#8203;(boolean&nbsp;doFlush)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#consumerUnSubscribeAllTopics(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">consumerUnSubscribeAllTopics</a></span>&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</code></th>
<td class="colLast">
<div class="block">Unsubscribe from all the topics being consumed for the partition in partitionConsumptionState</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>protected <a href="LeaderProducerCallback.html" title="class in com.linkedin.davinci.kafka.consumer">LeaderProducerCallback</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createProducerCallback(com.linkedin.venice.pubsub.api.PubSubMessage,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,com.linkedin.davinci.kafka.consumer.LeaderProducedRecordContext,int,java.lang.String,long)">createProducerCallback</a></span>&#8203;(<a href="../../../venice/pubsub/api/PubSubMessage.html" title="interface in com.linkedin.venice.pubsub.api">PubSubMessage</a>&lt;<a href="../../../venice/message/KafkaKey.html" title="class in com.linkedin.venice.message">KafkaKey</a>,&#8203;<a href="../../../venice/kafka/protocol/KafkaMessageEnvelope.html" title="class in com.linkedin.venice.kafka.protocol">KafkaMessageEnvelope</a>,&#8203;java.lang.Long&gt;&nbsp;consumerRecord,
                      <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState,
                      <a href="LeaderProducedRecordContext.html" title="class in com.linkedin.davinci.kafka.consumer">LeaderProducedRecordContext</a>&nbsp;leaderProducedRecordContext,
                      int&nbsp;subPartition,
                      java.lang.String&nbsp;kafkaUrl,
                      long&nbsp;beforeProcessingRecordTimestampNs)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>protected <a href="StoreIngestionTask.DelegateConsumerRecordResult.html" title="enum in com.linkedin.davinci.kafka.consumer">StoreIngestionTask.DelegateConsumerRecordResult</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#delegateConsumerRecord(com.linkedin.venice.pubsub.api.PubSubMessage,int,java.lang.String,int,long,long)">delegateConsumerRecord</a></span>&#8203;(<a href="../../../venice/pubsub/api/PubSubMessage.html" title="interface in com.linkedin.venice.pubsub.api">PubSubMessage</a>&lt;<a href="../../../venice/message/KafkaKey.html" title="class in com.linkedin.venice.message">KafkaKey</a>,&#8203;<a href="../../../venice/kafka/protocol/KafkaMessageEnvelope.html" title="class in com.linkedin.venice.kafka.protocol">KafkaMessageEnvelope</a>,&#8203;java.lang.Long&gt;&nbsp;consumerRecord,
                      int&nbsp;subPartition,
                      java.lang.String&nbsp;kafkaUrl,
                      int&nbsp;kafkaClusterId,
                      long&nbsp;beforeProcessingPerRecordTimestampNs,
                      long&nbsp;beforeProcessingBatchRecordsTimestampMs)</code></th>
<td class="colLast">
<div class="block">The goal of this function is to possibly produce the incoming kafka message consumed from local VT, remote VT, RT or SR topic to
 local VT if needed.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#demoteToStandby(com.linkedin.venice.pubsub.api.PubSubTopicPartition,com.linkedin.davinci.helix.LeaderFollowerPartitionStateModel.LeaderSessionIdChecker)">demoteToStandby</a></span>&#8203;(<a href="../../../venice/pubsub/api/PubSubTopicPartition.html" title="interface in com.linkedin.venice.pubsub.api">PubSubTopicPartition</a>&nbsp;topicPartition,
               <a href="../../helix/LeaderFollowerPartitionStateModel.LeaderSessionIdChecker.html" title="class in com.linkedin.davinci.helix">LeaderFollowerPartitionStateModel.LeaderSessionIdChecker</a>&nbsp;checker)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAndUpdateLeaderCompletedState(com.linkedin.venice.message.KafkaKey,com.linkedin.venice.kafka.protocol.KafkaMessageEnvelope,com.linkedin.venice.kafka.protocol.ControlMessage,com.linkedin.venice.pubsub.api.PubSubMessageHeaders,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">getAndUpdateLeaderCompletedState</a></span>&#8203;(<a href="../../../venice/message/KafkaKey.html" title="class in com.linkedin.venice.message">KafkaKey</a>&nbsp;kafkaKey,
                                <a href="../../../venice/kafka/protocol/KafkaMessageEnvelope.html" title="class in com.linkedin.venice.kafka.protocol">KafkaMessageEnvelope</a>&nbsp;kafkaValue,
                                <a href="../../../venice/kafka/protocol/ControlMessage.html" title="class in com.linkedin.venice.kafka.protocol">ControlMessage</a>&nbsp;controlMessage,
                                <a href="../../../venice/pubsub/api/PubSubMessageHeaders.html" title="class in com.linkedin.venice.pubsub.api">PubSubMessageHeaders</a>&nbsp;pubSubMessageHeaders,
                                <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</code></th>
<td class="colLast">
<div class="block">HeartBeat SOS messages carry the leader completion state in the header.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getBatchFollowerOffsetLag()">getBatchFollowerOffsetLag</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getBatchLeaderOffsetLag()">getBatchLeaderOffsetLag</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getBatchReplicationLag()">getBatchReplicationLag</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>protected java.util.Set&lt;java.lang.String&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getConsumptionSourceKafkaAddress(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">getConsumptionSourceKafkaAddress</a></span>&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getFollowerOffsetLag()">getFollowerOffsetLag</a></span>()</code></th>
<td class="colLast">
<div class="block">Measure the offset lag between follower and leader</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getHybridFollowerOffsetLag()">getHybridFollowerOffsetLag</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getHybridLeaderOffsetLag()">getHybridLeaderOffsetLag</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>protected long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getLatestConsumedUpstreamOffsetForHybridOffsetLagMeasurement(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,java.lang.String)">getLatestConsumedUpstreamOffsetForHybridOffsetLagMeasurement</a></span>&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;pcs,
                                                            java.lang.String&nbsp;ignoredKafkaUrl)</code></th>
<td class="colLast">
<div class="block">For regular L/F stores without A/A enabled, there is always only one real-time source.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>protected long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getLatestPersistedUpstreamOffsetForHybridOffsetLagMeasurement(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,java.lang.String)">getLatestPersistedUpstreamOffsetForHybridOffsetLagMeasurement</a></span>&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;pcs,
                                                             java.lang.String&nbsp;ignoredUpstreamKafkaUrl)</code></th>
<td class="colLast">
<div class="block">For L/F or NR, there is only one entry in upstreamOffsetMap whose key is NON_AA_REPLICATION_UPSTREAM_OFFSET_MAP_KEY.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getLeaderOffsetLag()">getLeaderOffsetLag</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>protected java.util.Set&lt;java.lang.String&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRealTimeDataSourceKafkaAddress(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">getRealTimeDataSourceKafkaAddress</a></span>&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRegionHybridOffsetLag(int)">getRegionHybridOffsetLag</a></span>&#8203;(int&nbsp;regionId)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getSubPartitionId(byte%5B%5D,com.linkedin.venice.pubsub.api.PubSubTopicPartition)">getSubPartitionId</a></span>&#8203;(byte[]&nbsp;key,
                 <a href="../../../venice/pubsub/api/PubSubTopicPartition.html" title="interface in com.linkedin.venice.pubsub.api">PubSubTopicPartition</a>&nbsp;topicPartition)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>protected long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getTopicPartitionOffsetByKafkaURL(java.lang.CharSequence,com.linkedin.venice.pubsub.api.PubSubTopicPartition,long)">getTopicPartitionOffsetByKafkaURL</a></span>&#8203;(java.lang.CharSequence&nbsp;kafkaURL,
                                 <a href="../../../venice/pubsub/api/PubSubTopicPartition.html" title="interface in com.linkedin.venice.pubsub.api">PubSubTopicPartition</a>&nbsp;pubSubTopicPartition,
                                 long&nbsp;rewindStartTimestamp)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>protected <a href="../../../venice/utils/lazy/Lazy.html" title="interface in com.linkedin.venice.utils.lazy">Lazy</a>&lt;<a href="../../../venice/writer/VeniceWriter.html" title="class in com.linkedin.venice.writer">VeniceWriter</a>&lt;byte[],&#8203;byte[],&#8203;byte[]&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getVeniceWriter()">getVeniceWriter</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getWriteComputeErrorCode()">getWriteComputeErrorCode</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isHybridFollower(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">isHybridFollower</a></span>&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isLeader(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">isLeader</a></span>&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isReadyToServeAnnouncedWithRTLag()">isReadyToServeAnnouncedWithRTLag</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isRealTimeBufferReplayStarted(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">isRealTimeBufferReplayStarted</a></span>&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#leaderExecuteTopicSwitch(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,com.linkedin.venice.kafka.protocol.TopicSwitch,com.linkedin.venice.pubsub.api.PubSubTopic)">leaderExecuteTopicSwitch</a></span>&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState,
                        <a href="../../../venice/kafka/protocol/TopicSwitch.html" title="class in com.linkedin.venice.kafka.protocol">TopicSwitch</a>&nbsp;topicSwitch,
                        <a href="../../../venice/pubsub/api/PubSubTopic.html" title="interface in com.linkedin.venice.pubsub.api">PubSubTopic</a>&nbsp;newSourceTopic)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>protected java.nio.ByteBuffer</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#maybeCompressData(int,java.nio.ByteBuffer,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">maybeCompressData</a></span>&#8203;(int&nbsp;partition,
                 java.nio.ByteBuffer&nbsp;data,
                 <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</code></th>
<td class="colLast">
<div class="block">Compresses data in a bytebuffer when consuming from rt as a leader node and compression is enabled for the store
 version for which we're consuming data.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>protected java.util.Set&lt;java.lang.String&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#maybeSendIngestionHeartbeat()">maybeSendIngestionHeartbeat</a></span>()</code></th>
<td class="colLast">
<div class="block">For hybrid stores only, the leader periodically writes a special SOS message to the RT topic with the following properties: <br>
 1.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>protected long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#measureHybridOffsetLag(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,boolean)">measureHybridOffsetLag</a></span>&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState,
                      boolean&nbsp;shouldLogLag)</code></th>
<td class="colLast">
<div class="block">For Leader/Follower state model, we already keep track of the consumption progress in leader, so directly calculate
 the lag with the real-time topic and the leader consumption offset.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>protected long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#measureRTOffsetLagForMultiRegions(java.util.Set,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,boolean)">measureRTOffsetLagForMultiRegions</a></span>&#8203;(java.util.Set&lt;java.lang.String&gt;&nbsp;sourceRealTimeTopicKafkaURLs,
                                 <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState,
                                 boolean&nbsp;shouldLogLag)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>protected long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#measureRTOffsetLagForSingleRegion(java.lang.String,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,boolean)">measureRTOffsetLagForSingleRegion</a></span>&#8203;(java.lang.String&nbsp;sourceRealTimeTopicKafkaURL,
                                 <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;pcs,
                                 boolean&nbsp;shouldLog)</code></th>
<td class="colLast">
<div class="block">This method fetches/calculates latest leader persisted offset and last offset in RT topic.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#processConsumerAction(com.linkedin.davinci.kafka.consumer.ConsumerAction,com.linkedin.venice.meta.Store)">processConsumerAction</a></span>&#8203;(<a href="ConsumerAction.html" title="class in com.linkedin.davinci.kafka.consumer">ConsumerAction</a>&nbsp;message,
                     <a href="../../../venice/meta/Store.html" title="interface in com.linkedin.venice.meta">Store</a>&nbsp;store)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#processMessageAndMaybeProduceToKafka(com.linkedin.venice.pubsub.api.PubSubMessage,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,int,java.lang.String,int,long,long)">processMessageAndMaybeProduceToKafka</a></span>&#8203;(<a href="../../../venice/pubsub/api/PubSubMessage.html" title="interface in com.linkedin.venice.pubsub.api">PubSubMessage</a>&lt;<a href="../../../venice/message/KafkaKey.html" title="class in com.linkedin.venice.message">KafkaKey</a>,&#8203;<a href="../../../venice/kafka/protocol/KafkaMessageEnvelope.html" title="class in com.linkedin.venice.kafka.protocol">KafkaMessageEnvelope</a>,&#8203;java.lang.Long&gt;&nbsp;consumerRecord,
                                    <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState,
                                    int&nbsp;subPartition,
                                    java.lang.String&nbsp;kafkaUrl,
                                    int&nbsp;kafkaClusterId,
                                    long&nbsp;beforeProcessingRecordTimestampNs,
                                    long&nbsp;currentTimeForMetricsMs)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#processTopicSwitch(com.linkedin.venice.kafka.protocol.ControlMessage,int,long,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">processTopicSwitch</a></span>&#8203;(<a href="../../../venice/kafka/protocol/ControlMessage.html" title="class in com.linkedin.venice.kafka.protocol">ControlMessage</a>&nbsp;controlMessage,
                  int&nbsp;partition,
                  long&nbsp;offset,
                  <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</code></th>
<td class="colLast">
<div class="block">Process <a href="../../../venice/kafka/protocol/TopicSwitch.html" title="class in com.linkedin.venice.kafka.protocol"><code>TopicSwitch</code></a> control message at given partition offset for a specific <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer"><code>PartitionConsumptionState</code></a>.</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#processVersionSwapMessage(com.linkedin.venice.kafka.protocol.ControlMessage,int,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">processVersionSwapMessage</a></span>&#8203;(<a href="../../../venice/kafka/protocol/ControlMessage.html" title="class in com.linkedin.venice.kafka.protocol">ControlMessage</a>&nbsp;controlMessage,
                         int&nbsp;partition,
                         <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</code></th>
<td class="colLast">
<div class="block">This isn't really used for ingestion outside of A/A, so we NoOp here and rely on the actual implementation in
  <a href="ActiveActiveStoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer"><code>ActiveActiveStoreIngestionTask</code></a></div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#produceToLocalKafka(com.linkedin.venice.pubsub.api.PubSubMessage,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,com.linkedin.davinci.kafka.consumer.LeaderProducedRecordContext,java.util.function.BiConsumer,int,java.lang.String,int,long)">produceToLocalKafka</a></span>&#8203;(<a href="../../../venice/pubsub/api/PubSubMessage.html" title="interface in com.linkedin.venice.pubsub.api">PubSubMessage</a>&lt;<a href="../../../venice/message/KafkaKey.html" title="class in com.linkedin.venice.message">KafkaKey</a>,&#8203;<a href="../../../venice/kafka/protocol/KafkaMessageEnvelope.html" title="class in com.linkedin.venice.kafka.protocol">KafkaMessageEnvelope</a>,&#8203;java.lang.Long&gt;&nbsp;consumerRecord,
                   <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState,
                   <a href="LeaderProducedRecordContext.html" title="class in com.linkedin.davinci.kafka.consumer">LeaderProducedRecordContext</a>&nbsp;leaderProducedRecordContext,
                   java.util.function.BiConsumer&lt;<a href="../../../venice/writer/ChunkAwareCallback.html" title="interface in com.linkedin.venice.writer">ChunkAwareCallback</a>,&#8203;<a href="../../../venice/writer/LeaderMetadataWrapper.html" title="class in com.linkedin.venice.writer">LeaderMetadataWrapper</a>&gt;&nbsp;produceFunction,
                   int&nbsp;subPartition,
                   java.lang.String&nbsp;kafkaUrl,
                   int&nbsp;kafkaClusterId,
                   long&nbsp;beforeProcessingRecordTimestampNs)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#promoteToLeader(com.linkedin.venice.pubsub.api.PubSubTopicPartition,com.linkedin.davinci.helix.LeaderFollowerPartitionStateModel.LeaderSessionIdChecker)">promoteToLeader</a></span>&#8203;(<a href="../../../venice/pubsub/api/PubSubTopicPartition.html" title="interface in com.linkedin.venice.pubsub.api">PubSubTopicPartition</a>&nbsp;topicPartition,
               <a href="../../helix/LeaderFollowerPartitionStateModel.LeaderSessionIdChecker.html" title="class in com.linkedin.davinci.helix">LeaderFollowerPartitionStateModel.LeaderSessionIdChecker</a>&nbsp;checker)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#recordHeartbeatReceived(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,com.linkedin.venice.pubsub.api.PubSubMessage,java.lang.String)">recordHeartbeatReceived</a></span>&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState,
                       <a href="../../../venice/pubsub/api/PubSubMessage.html" title="interface in com.linkedin.venice.pubsub.api">PubSubMessage</a>&lt;<a href="../../../venice/message/KafkaKey.html" title="class in com.linkedin.venice.message">KafkaKey</a>,&#8203;<a href="../../../venice/kafka/protocol/KafkaMessageEnvelope.html" title="class in com.linkedin.venice.kafka.protocol">KafkaMessageEnvelope</a>,&#8203;java.lang.Long&gt;&nbsp;consumerRecord,
                       java.lang.String&nbsp;kafkaUrl)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#recordProcessedRecordStats(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,int)">recordProcessedRecordStats</a></span>&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState,
                          int&nbsp;processedRecordSize)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#recordWriterStats(long,long,long,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">recordWriterStats</a></span>&#8203;(long&nbsp;consumerTimestampMs,
                 long&nbsp;producerBrokerLatencyMs,
                 long&nbsp;brokerConsumerLatencyMs,
                 <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#reportIfCatchUpVersionTopicOffset(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">reportIfCatchUpVersionTopicOffset</a></span>&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;pcs)</code></th>
<td class="colLast">
<div class="block">Check if the ingestion progress has reached to the end of the version topic.</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#shouldCheckLeaderCompleteStateInFollower()">shouldCheckLeaderCompleteStateInFollower</a></span>()</code></th>
<td class="colLast">
<div class="block">For non AA hybrid stores with AGGREGATE DRP, SIT reads from parent RT while the HB is written to the child RTs.</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#shouldCompressData(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">shouldCompressData</a></span>&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#shouldNewLeaderSwitchToRemoteConsumption(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">shouldNewLeaderSwitchToRemoteConsumption</a></span>&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#shouldPersistRecord(com.linkedin.venice.pubsub.api.PubSubMessage,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">shouldPersistRecord</a></span>&#8203;(<a href="../../../venice/pubsub/api/PubSubMessage.html" title="interface in com.linkedin.venice.pubsub.api">PubSubMessage</a>&lt;<a href="../../../venice/message/KafkaKey.html" title="class in com.linkedin.venice.message">KafkaKey</a>,&#8203;<a href="../../../venice/kafka/protocol/KafkaMessageEnvelope.html" title="class in com.linkedin.venice.kafka.protocol">KafkaMessageEnvelope</a>,&#8203;java.lang.Long&gt;&nbsp;record,
                   <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</code></th>
<td class="colLast">
<div class="block">Additional safeguards in Leader/Follower ingestion:
 1.</div>
</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#shouldProcessRecord(com.linkedin.venice.pubsub.api.PubSubMessage,int)">shouldProcessRecord</a></span>&#8203;(<a href="../../../venice/pubsub/api/PubSubMessage.html" title="interface in com.linkedin.venice.pubsub.api">PubSubMessage</a>&lt;<a href="../../../venice/message/KafkaKey.html" title="class in com.linkedin.venice.message">KafkaKey</a>,&#8203;<a href="../../../venice/kafka/protocol/KafkaMessageEnvelope.html" title="class in com.linkedin.venice.kafka.protocol">KafkaMessageEnvelope</a>,&#8203;java.lang.Long&gt;&nbsp;record,
                   int&nbsp;subPartition)</code></th>
<td class="colLast">
<div class="block">For Leader/Follower model, the follower should have the same kind of check as the Online/Offline model;
 for leader, it's possible that it consumers from real-time topic or GF topic.</div>
</td>
</tr>
<tr id="i53" class="rowColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#shouldProduceToVersionTopic(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">shouldProduceToVersionTopic</a></span>&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</code></th>
<td class="colLast">
<div class="block">For the corresponding partition being tracked in `partitionConsumptionState`, if it's in LEADER state and it's
 not consuming from version topic, it should produce the new message to version topic; besides, if LEADER is
 consuming remotely, it should also produce to local fabric.</div>
</td>
</tr>
<tr id="i54" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#startConsumingAsLeader(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">startConsumingAsLeader</a></span>&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i55" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#startConsumingAsLeaderInTransitionFromStandby(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">startConsumingAsLeaderInTransitionFromStandby</a></span>&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i56" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#syncConsumedUpstreamRTOffsetMapIfNeeded(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,java.util.Map)">syncConsumedUpstreamRTOffsetMapIfNeeded</a></span>&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;pcs,
                                       java.util.Map&lt;java.lang.String,&#8203;java.lang.Long&gt;&nbsp;upstreamStartOffsetByKafkaURL)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i57" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#syncTopicSwitchToIngestionMetadataService(com.linkedin.venice.kafka.protocol.TopicSwitch,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">syncTopicSwitchToIngestionMetadataService</a></span>&#8203;(<a href="../../../venice/kafka/protocol/TopicSwitch.html" title="class in com.linkedin.venice.kafka.protocol">TopicSwitch</a>&nbsp;topicSwitch,
                                         <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i58" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#updateLatestInMemoryLeaderConsumedRTOffset(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,java.lang.String,long)">updateLatestInMemoryLeaderConsumedRTOffset</a></span>&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;pcs,
                                          java.lang.String&nbsp;ignoredKafkaUrl,
                                          long&nbsp;offset)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i59" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#updateLatestInMemoryProcessedOffset(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,com.linkedin.venice.pubsub.api.PubSubMessage,com.linkedin.davinci.kafka.consumer.LeaderProducedRecordContext,java.lang.String,boolean)">updateLatestInMemoryProcessedOffset</a></span>&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState,
                                   <a href="../../../venice/pubsub/api/PubSubMessage.html" title="interface in com.linkedin.venice.pubsub.api">PubSubMessage</a>&lt;<a href="../../../venice/message/KafkaKey.html" title="class in com.linkedin.venice.message">KafkaKey</a>,&#8203;<a href="../../../venice/kafka/protocol/KafkaMessageEnvelope.html" title="class in com.linkedin.venice.kafka.protocol">KafkaMessageEnvelope</a>,&#8203;java.lang.Long&gt;&nbsp;consumerRecordWrapper,
                                   <a href="LeaderProducedRecordContext.html" title="class in com.linkedin.davinci.kafka.consumer">LeaderProducedRecordContext</a>&nbsp;leaderProducedRecordContext,
                                   java.lang.String&nbsp;kafkaUrl,
                                   boolean&nbsp;dryRun)</code></th>
<td class="colLast">
<div class="block">Maintain the latest processed offsets by drainers in memory; in most of the time, these offsets are ahead of the
 checkpoint offsets inside <a href="../../../venice/offsets/OffsetRecord.html" title="class in com.linkedin.venice.offsets"><code>OffsetRecord</code></a>.</div>
</td>
</tr>
<tr id="i60" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#updateLeaderTopicOnFollower(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">updateLeaderTopicOnFollower</a></span>&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i61" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#updateOffsetMetadataInOffsetRecord(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">updateOffsetMetadataInOffsetRecord</a></span>&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</code></th>
<td class="colLast">
<div class="block">Sync the metadata about offset in <a href="../../../venice/offsets/OffsetRecord.html" title="class in com.linkedin.venice.offsets"><code>OffsetRecord</code></a>.</div>
</td>
</tr>
<tr id="i62" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#updateOffsetsFromConsumerRecord(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,com.linkedin.venice.pubsub.api.PubSubMessage,com.linkedin.davinci.kafka.consumer.LeaderProducedRecordContext,com.linkedin.davinci.kafka.consumer.LeaderFollowerStoreIngestionTask.UpdateVersionTopicOffset,com.linkedin.davinci.kafka.consumer.LeaderFollowerStoreIngestionTask.UpdateUpstreamTopicOffset,com.linkedin.davinci.kafka.consumer.LeaderFollowerStoreIngestionTask.GetLastKnownUpstreamTopicOffset,java.util.function.Supplier,boolean)">updateOffsetsFromConsumerRecord</a></span>&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState,
                               <a href="../../../venice/pubsub/api/PubSubMessage.html" title="interface in com.linkedin.venice.pubsub.api">PubSubMessage</a>&lt;<a href="../../../venice/message/KafkaKey.html" title="class in com.linkedin.venice.message">KafkaKey</a>,&#8203;<a href="../../../venice/kafka/protocol/KafkaMessageEnvelope.html" title="class in com.linkedin.venice.kafka.protocol">KafkaMessageEnvelope</a>,&#8203;java.lang.Long&gt;&nbsp;consumerRecord,
                               <a href="LeaderProducedRecordContext.html" title="class in com.linkedin.davinci.kafka.consumer">LeaderProducedRecordContext</a>&nbsp;leaderProducedRecordContext,
                               com.linkedin.davinci.kafka.consumer.LeaderFollowerStoreIngestionTask.UpdateVersionTopicOffset&nbsp;updateVersionTopicOffsetFunction,
                               com.linkedin.davinci.kafka.consumer.LeaderFollowerStoreIngestionTask.UpdateUpstreamTopicOffset&nbsp;updateUpstreamTopicOffsetFunction,
                               com.linkedin.davinci.kafka.consumer.LeaderFollowerStoreIngestionTask.GetLastKnownUpstreamTopicOffset&nbsp;lastKnownUpstreamTopicOffsetSupplier,
                               java.util.function.Supplier&lt;java.lang.String&gt;&nbsp;sourceKafkaUrlSupplier,
                               boolean&nbsp;dryRun)</code></th>
<td class="colLast">
<div class="block">A helper function to the latest in-memory offsets processed by drainers in <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer"><code>PartitionConsumptionState</code></a>,
 after processing the given <a href="../../../venice/pubsub/api/PubSubMessage.html" title="interface in com.linkedin.venice.pubsub.api"><code>PubSubMessage</code></a>.</div>
</td>
</tr>
<tr id="i63" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#waitForAllMessageToBeProcessedFromTopicPartition(com.linkedin.venice.pubsub.api.PubSubTopicPartition,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">waitForAllMessageToBeProcessedFromTopicPartition</a></span>&#8203;(<a href="../../../venice/pubsub/api/PubSubTopicPartition.html" title="interface in com.linkedin.venice.pubsub.api">PubSubTopicPartition</a>&nbsp;topicPartition,
                                                <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</code></th>
<td class="colLast">
<div class="block">Besides draining messages in the drainer queue, wait for the last producer future.</div>
</td>
</tr>
<tr id="i64" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#waitForLastLeaderPersistFuture(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,java.lang.String)">waitForLastLeaderPersistFuture</a></span>&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState,
                              java.lang.String&nbsp;errorMsg)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.com.linkedin.davinci.kafka.consumer.StoreIngestionTask">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;com.linkedin.davinci.kafka.consumer.<a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></h3>
<code><a href="StoreIngestionTask.html#checkIngestionProgress(com.linkedin.venice.meta.Store)">checkIngestionProgress</a>, <a href="StoreIngestionTask.html#cloneProducerStates(int,com.linkedin.davinci.validation.KafkaDataIntegrityValidator)">cloneProducerStates</a>, <a href="StoreIngestionTask.html#close()">close</a>, <a href="StoreIngestionTask.html#consumerBatchUnsubscribe(java.util.Set)">consumerBatchUnsubscribe</a>, <a href="StoreIngestionTask.html#consumerHasAnySubscription()">consumerHasAnySubscription</a>, <a href="StoreIngestionTask.html#consumerHasSubscription(com.linkedin.venice.pubsub.api.PubSubTopic,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">consumerHasSubscription</a>, <a href="StoreIngestionTask.html#consumerResetOffset(com.linkedin.venice.pubsub.api.PubSubTopic,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">consumerResetOffset</a>, <a href="StoreIngestionTask.html#consumerSubscribe(com.linkedin.venice.pubsub.api.PubSubTopicPartition,long,java.lang.String)">consumerSubscribe</a>, <a href="StoreIngestionTask.html#consumerUnSubscribe(com.linkedin.venice.pubsub.api.PubSubTopic,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">consumerUnSubscribe</a>, <a href="StoreIngestionTask.html#createKafkaConsumerProperties(java.util.Properties,java.lang.String,boolean)">createKafkaConsumerProperties</a>, <a href="StoreIngestionTask.html#disableMetricsEmission()">disableMetricsEmission</a>, <a href="StoreIngestionTask.html#dumpPartitionConsumptionStates(com.linkedin.davinci.listener.response.AdminResponse,com.linkedin.venice.utils.ComplementSet)">dumpPartitionConsumptionStates</a>, <a href="StoreIngestionTask.html#dumpStoreVersionState(com.linkedin.davinci.listener.response.AdminResponse)">dumpStoreVersionState</a>, <a href="StoreIngestionTask.html#enableMetricsEmission()">enableMetricsEmission</a>, <a href="StoreIngestionTask.html#getAmplificationFactor()">getAmplificationFactor</a>, <a href="StoreIngestionTask.html#getCompressionStrategy()">getCompressionStrategy</a>, <a href="StoreIngestionTask.html#getCompressor()">getCompressor</a>, <a href="StoreIngestionTask.html#getFailedIngestionPartitionCount()">getFailedIngestionPartitionCount</a>, <a href="StoreIngestionTask.html#getHostLevelIngestionStats()">getHostLevelIngestionStats</a>, <a href="StoreIngestionTask.html#getIngestionTaskName()">getIngestionTaskName</a>, <a href="StoreIngestionTask.html#getKafkaVersionTopic()">getKafkaVersionTopic</a>, <a href="StoreIngestionTask.html#getLatestConsumedProducerTimestampWithSubPartition(long,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">getLatestConsumedProducerTimestampWithSubPartition</a>, <a href="StoreIngestionTask.html#getLeaderState(int)">getLeaderState</a>, <a href="StoreIngestionTask.html#getOffsetToOnlineLagThresholdPerPartition(java.util.Optional,java.lang.String,int)">getOffsetToOnlineLagThresholdPerPartition</a>, <a href="StoreIngestionTask.html#getPartitionConsumptionState(int)">getPartitionConsumptionState</a>, <a href="StoreIngestionTask.html#getPartitionOffsetLagBasedOnMetrics(java.lang.String,com.linkedin.venice.pubsub.api.PubSubTopic,int)">getPartitionOffsetLagBasedOnMetrics</a>, <a href="StoreIngestionTask.html#getSchemaRepo()">getSchemaRepo</a>, <a href="StoreIngestionTask.html#getServerConfig()">getServerConfig</a>, <a href="StoreIngestionTask.html#getStatusReportAdapter()">getStatusReportAdapter</a>, <a href="StoreIngestionTask.html#getStorageEngine()">getStorageEngine</a>, <a href="StoreIngestionTask.html#getStoreName()">getStoreName</a>, <a href="StoreIngestionTask.html#getTopicManager(java.lang.String)">getTopicManager</a>, <a href="StoreIngestionTask.html#getTopicPartitionEndOffSet(java.lang.String,com.linkedin.venice.pubsub.api.PubSubTopic,int)">getTopicPartitionEndOffSet</a>, <a href="StoreIngestionTask.html#getVersionedDIVStats()">getVersionedDIVStats</a>, <a href="StoreIngestionTask.html#getVersionIngestionStats()">getVersionIngestionStats</a>, <a href="StoreIngestionTask.html#getVersionNumber()">getVersionNumber</a>, <a href="StoreIngestionTask.html#getVersionTopic()">getVersionTopic</a>, <a href="StoreIngestionTask.html#hasAnyPartitionConsumptionState(java.util.function.Predicate)">hasAnyPartitionConsumptionState</a>, <a href="StoreIngestionTask.html#hasAnySubscription()">hasAnySubscription</a>, <a href="StoreIngestionTask.html#hasPendingPartitionIngestionAction(int)">hasPendingPartitionIngestionAction</a>, <a href="StoreIngestionTask.html#isActiveActiveReplicationEnabled()">isActiveActiveReplicationEnabled</a>, <a href="StoreIngestionTask.html#isChunked()">isChunked</a>, <a href="StoreIngestionTask.html#isFutureVersion()">isFutureVersion</a>, <a href="StoreIngestionTask.html#isHybridMode()">isHybridMode</a>, <a href="StoreIngestionTask.html#isIngestionTaskActive()">isIngestionTaskActive</a>, <a href="StoreIngestionTask.html#isMetricsEmissionEnabled()">isMetricsEmissionEnabled</a>, <a href="StoreIngestionTask.html#isPartitionConsumingOrHasPendingIngestionAction(int)">isPartitionConsumingOrHasPendingIngestionAction</a>, <a href="StoreIngestionTask.html#isProducingVersionTopicHealthy()">isProducingVersionTopicHealthy</a>, <a href="StoreIngestionTask.html#isReadyToServe(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">isReadyToServe</a>, <a href="StoreIngestionTask.html#isRunning()">isRunning</a>, <a href="StoreIngestionTask.html#isSegmentControlMsg(com.linkedin.venice.kafka.protocol.enums.ControlMessageType)">isSegmentControlMsg</a>, <a href="StoreIngestionTask.html#isStuckByMemoryConstraint()">isStuckByMemoryConstraint</a>, <a href="StoreIngestionTask.html#isTransientRecordBufferUsed()">isTransientRecordBufferUsed</a>, <a href="StoreIngestionTask.html#isUserSystemStore()">isUserSystemStore</a>, <a href="StoreIngestionTask.html#kill()">kill</a>, <a href="StoreIngestionTask.html#logStorageOperationWhileUnsubscribed(int)">logStorageOperationWhileUnsubscribed</a>, <a href="StoreIngestionTask.html#measureLagWithCallToPubSub(java.lang.String,com.linkedin.venice.pubsub.api.PubSubTopic,int,long)">measureLagWithCallToPubSub</a>, <a href="StoreIngestionTask.html#measureLagWithCallToPubSub(java.lang.String,com.linkedin.venice.pubsub.api.PubSubTopic,int,long,java.util.function.Function)">measureLagWithCallToPubSub</a>, <a href="StoreIngestionTask.html#minZeroLag(long)">minZeroLag</a>, <a href="StoreIngestionTask.html#nextSeqNum()">nextSeqNum</a>, <a href="StoreIngestionTask.html#processCommonConsumerAction(com.linkedin.davinci.kafka.consumer.ConsumerAction)">processCommonConsumerAction</a>, <a href="StoreIngestionTask.html#processConsumerRecord(com.linkedin.venice.pubsub.api.PubSubMessage,com.linkedin.davinci.kafka.consumer.LeaderProducedRecordContext,int,java.lang.String,long)">processConsumerRecord</a>, <a href="StoreIngestionTask.html#processEndOfIncrementalPush(com.linkedin.venice.kafka.protocol.ControlMessage,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">processEndOfIncrementalPush</a>, <a href="StoreIngestionTask.html#processEndOfPush(com.linkedin.venice.kafka.protocol.KafkaMessageEnvelope,int,long,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">processEndOfPush</a>, <a href="StoreIngestionTask.html#processStartOfIncrementalPush(com.linkedin.venice.kafka.protocol.ControlMessage,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">processStartOfIncrementalPush</a>, <a href="StoreIngestionTask.html#produceToStoreBufferService(com.linkedin.venice.pubsub.api.PubSubMessage,com.linkedin.davinci.kafka.consumer.LeaderProducedRecordContext,int,java.lang.String,long,long)">produceToStoreBufferService</a>, <a href="StoreIngestionTask.html#produceToStoreBufferServiceOrKafka(java.lang.Iterable,com.linkedin.venice.pubsub.api.PubSubTopicPartition,java.lang.String,int)">produceToStoreBufferServiceOrKafka</a>, <a href="StoreIngestionTask.html#putInStorageEngine(int,byte%5B%5D,com.linkedin.venice.kafka.protocol.Put)">putInStorageEngine</a>, <a href="StoreIngestionTask.html#recordChecksumVerificationFailure()">recordChecksumVerificationFailure</a>, <a href="StoreIngestionTask.html#removeFromStorageEngine(int,byte%5B%5D,com.linkedin.venice.kafka.protocol.Delete)">removeFromStorageEngine</a>, <a href="StoreIngestionTask.html#reportError(java.lang.String,int,java.lang.Exception)">reportError</a>, <a href="StoreIngestionTask.html#resetPartitionConsumptionOffset(com.linkedin.venice.pubsub.api.PubSubTopicPartition)">resetPartitionConsumptionOffset</a>, <a href="StoreIngestionTask.html#resolveSourceKafkaServersWithinTopicSwitch(com.linkedin.venice.kafka.protocol.TopicSwitch)">resolveSourceKafkaServersWithinTopicSwitch</a>, <a href="StoreIngestionTask.html#run()">run</a>, <a href="StoreIngestionTask.html#setLastConsumerException(java.lang.Exception)">setLastConsumerException</a>, <a href="StoreIngestionTask.html#setLastStoreIngestionException(java.lang.Exception)">setLastStoreIngestionException</a>, <a href="StoreIngestionTask.html#setPartitionConsumptionState(int,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">setPartitionConsumptionState</a>, <a href="StoreIngestionTask.html#shouldUpdateUpstreamOffset(com.linkedin.venice.pubsub.api.PubSubMessage)">shouldUpdateUpstreamOffset</a>, <a href="StoreIngestionTask.html#shutdown(int)">shutdown</a>, <a href="StoreIngestionTask.html#subscribePartition(com.linkedin.venice.pubsub.api.PubSubTopicPartition,java.util.Optional)">subscribePartition</a>, <a href="StoreIngestionTask.html#subscribePartition(com.linkedin.venice.pubsub.api.PubSubTopicPartition,java.util.Optional,boolean)">subscribePartition</a>, <a href="StoreIngestionTask.html#throwIfNotRunning()">throwIfNotRunning</a>, <a href="StoreIngestionTask.html#throwOrLogStorageFailureDependingIfStillSubscribed(int,com.linkedin.venice.exceptions.VeniceException)">throwOrLogStorageFailureDependingIfStillSubscribed</a>, <a href="StoreIngestionTask.html#unSubscribePartition(com.linkedin.venice.pubsub.api.PubSubTopicPartition)">unSubscribePartition</a>, <a href="StoreIngestionTask.html#unSubscribePartition(com.linkedin.venice.pubsub.api.PubSubTopicPartition,boolean)">unSubscribePartition</a>, <a href="StoreIngestionTask.html#updateOffsetMetadataAndSync(java.lang.String,int)">updateOffsetMetadataAndSync</a>, <a href="StoreIngestionTask.html#validateMessage(com.linkedin.davinci.validation.KafkaDataIntegrityValidator,com.linkedin.venice.pubsub.api.PubSubMessage,boolean,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">validateMessage</a>, <a href="StoreIngestionTask.html#waitVersionStateAvailable(java.lang.String)">waitVersionStateAvailable</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a id="veniceWriter">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>veniceWriter</h4>
<pre>protected final&nbsp;<a href="../../../venice/utils/lazy/Lazy.html" title="interface in com.linkedin.venice.utils.lazy">Lazy</a>&lt;<a href="../../../venice/writer/VeniceWriter.html" title="class in com.linkedin.venice.writer">VeniceWriter</a>&lt;byte[],&#8203;byte[],&#8203;byte[]&gt;&gt; veniceWriter</pre>
<div class="block">N.B.:
    With L/F+native replication and many Leader partitions getting assigned to a single SN this <a href="../../../venice/writer/VeniceWriter.html" title="class in com.linkedin.venice.writer"><code>VeniceWriter</code></a>
    may be called from multiple thread simultaneously, during start of batch push. Therefore, we wrap it in
    <a href="../../../venice/utils/lazy/Lazy.html" title="interface in com.linkedin.venice.utils.lazy"><code>Lazy</code></a> to initialize it in a thread safe way and to ensure that only one instance is created for the
    entire ingestion task.</div>
</li>
</ul>
<a id="kafkaClusterIdToUrlMap">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>kafkaClusterIdToUrlMap</h4>
<pre>protected final&nbsp;it.unimi.dsi.fastutil.ints.Int2ObjectMap&lt;java.lang.String&gt; kafkaClusterIdToUrlMap</pre>
</li>
</ul>
<a id="viewWriters">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>viewWriters</h4>
<pre>protected final&nbsp;java.util.Map&lt;java.lang.String,&#8203;<a href="../../store/view/VeniceViewWriter.html" title="class in com.linkedin.davinci.store.view">VeniceViewWriter</a>&gt; viewWriters</pre>
</li>
</ul>
<a id="storeDeserializerCache">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>storeDeserializerCache</h4>
<pre>protected final&nbsp;<a href="../../../venice/serialization/AvroStoreDeserializerCache.html" title="class in com.linkedin.venice.serialization">AvroStoreDeserializerCache</a> storeDeserializerCache</pre>
</li>
</ul>
<a id="VALID_LAG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>VALID_LAG</h4>
<pre>protected static final&nbsp;java.util.function.LongPredicate VALID_LAG</pre>
</li>
</ul>
<a id="LEADER_OFFSET_LAG_FILTER">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>LEADER_OFFSET_LAG_FILTER</h4>
<pre>public static final&nbsp;java.util.function.Predicate&lt;? super <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&gt; LEADER_OFFSET_LAG_FILTER</pre>
</li>
</ul>
</li>
</ul>
</section>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;(com.linkedin.davinci.kafka.consumer.StoreIngestionTaskFactory.Builder,com.linkedin.venice.meta.Store,com.linkedin.venice.meta.Version,java.util.Properties,java.util.function.BooleanSupplier,com.linkedin.davinci.config.VeniceStoreVersionConfig,int,boolean,java.util.Optional,java.util.function.Function)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>LeaderFollowerStoreIngestionTask</h4>
<pre>public&nbsp;LeaderFollowerStoreIngestionTask&#8203;(<a href="StoreIngestionTaskFactory.Builder.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTaskFactory.Builder</a>&nbsp;builder,
                                        <a href="../../../venice/meta/Store.html" title="interface in com.linkedin.venice.meta">Store</a>&nbsp;store,
                                        <a href="../../../venice/meta/Version.html" title="interface in com.linkedin.venice.meta">Version</a>&nbsp;version,
                                        java.util.Properties&nbsp;kafkaConsumerProperties,
                                        java.util.function.BooleanSupplier&nbsp;isCurrentVersion,
                                        <a href="../../config/VeniceStoreVersionConfig.html" title="class in com.linkedin.davinci.config">VeniceStoreVersionConfig</a>&nbsp;storeConfig,
                                        int&nbsp;errorPartitionId,
                                        boolean&nbsp;isIsolatedIngestion,
                                        java.util.Optional&lt;<a href="../../store/cache/backend/ObjectCacheBackend.html" title="class in com.linkedin.davinci.store.cache.backend">ObjectCacheBackend</a>&gt;&nbsp;cacheBackend,
                                        java.util.function.Function&lt;java.lang.Integer,&#8203;<a href="../../client/DaVinciRecordTransformer.html" title="class in com.linkedin.davinci.client">DaVinciRecordTransformer</a>&gt;&nbsp;getRecordTransformer)</pre>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="closeVeniceWriters(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>closeVeniceWriters</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;closeVeniceWriters&#8203;(boolean&nbsp;doFlush)</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="StoreIngestionTask.html#closeVeniceWriters(boolean)">closeVeniceWriters</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="closeVeniceViewWriters()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>closeVeniceViewWriters</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;closeVeniceViewWriters()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="StoreIngestionTask.html#closeVeniceViewWriters()">closeVeniceViewWriters</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="promoteToLeader(com.linkedin.venice.pubsub.api.PubSubTopicPartition,com.linkedin.davinci.helix.LeaderFollowerPartitionStateModel.LeaderSessionIdChecker)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>promoteToLeader</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;promoteToLeader&#8203;(<a href="../../../venice/pubsub/api/PubSubTopicPartition.html" title="interface in com.linkedin.venice.pubsub.api">PubSubTopicPartition</a>&nbsp;topicPartition,
                            <a href="../../helix/LeaderFollowerPartitionStateModel.LeaderSessionIdChecker.html" title="class in com.linkedin.davinci.helix">LeaderFollowerPartitionStateModel.LeaderSessionIdChecker</a>&nbsp;checker)</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="StoreIngestionTask.html#promoteToLeader(com.linkedin.venice.pubsub.api.PubSubTopicPartition,com.linkedin.davinci.helix.LeaderFollowerPartitionStateModel.LeaderSessionIdChecker)">promoteToLeader</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="demoteToStandby(com.linkedin.venice.pubsub.api.PubSubTopicPartition,com.linkedin.davinci.helix.LeaderFollowerPartitionStateModel.LeaderSessionIdChecker)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>demoteToStandby</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;demoteToStandby&#8203;(<a href="../../../venice/pubsub/api/PubSubTopicPartition.html" title="interface in com.linkedin.venice.pubsub.api">PubSubTopicPartition</a>&nbsp;topicPartition,
                            <a href="../../helix/LeaderFollowerPartitionStateModel.LeaderSessionIdChecker.html" title="class in com.linkedin.davinci.helix">LeaderFollowerPartitionStateModel.LeaderSessionIdChecker</a>&nbsp;checker)</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="StoreIngestionTask.html#demoteToStandby(com.linkedin.venice.pubsub.api.PubSubTopicPartition,com.linkedin.davinci.helix.LeaderFollowerPartitionStateModel.LeaderSessionIdChecker)">demoteToStandby</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="processConsumerAction(com.linkedin.davinci.kafka.consumer.ConsumerAction,com.linkedin.venice.meta.Store)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>processConsumerAction</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;processConsumerAction&#8203;(<a href="ConsumerAction.html" title="class in com.linkedin.davinci.kafka.consumer">ConsumerAction</a>&nbsp;message,
                                     <a href="../../../venice/meta/Store.html" title="interface in com.linkedin.venice.meta">Store</a>&nbsp;store)
                              throws java.lang.InterruptedException</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="StoreIngestionTask.html#processConsumerAction(com.linkedin.davinci.kafka.consumer.ConsumerAction,com.linkedin.venice.meta.Store)">processConsumerAction</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a id="checkLongRunningTaskState()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkLongRunningTaskState</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;checkLongRunningTaskState()
                                  throws java.lang.InterruptedException</pre>
<div class="block">The following function will be executed after processing all the quick actions in the consumer action queues,
 so that the long running actions doesn't block other partition's consumer actions. Besides, there is no thread
 sleeping operations in this function in order to be efficient, but this function will be invoked again and again in
 the main loop of the StoreIngestionTask to check whether some long-running actions can finish now.

 The only drawback is that for regular batch push, leader flag is never on at least a few minutes after the leader
 consumes the last message (END_OF_PUSH), which is an acceptable trade-off for us in order to share and test the
 same code path between regular push job, hybrid store and reprocessing job.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="StoreIngestionTask.html#checkLongRunningTaskState()">checkLongRunningTaskState</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a id="startConsumingAsLeaderInTransitionFromStandby(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>startConsumingAsLeaderInTransitionFromStandby</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;startConsumingAsLeaderInTransitionFromStandby&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</pre>
</li>
</ul>
<a id="calculateLeaderUpstreamOffsetWithTopicSwitch(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,com.linkedin.venice.kafka.protocol.TopicSwitch,com.linkedin.venice.pubsub.api.PubSubTopic,java.util.List)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>calculateLeaderUpstreamOffsetWithTopicSwitch</h4>
<pre class="methodSignature">protected&nbsp;java.util.Map&lt;java.lang.String,&#8203;java.lang.Long&gt;&nbsp;calculateLeaderUpstreamOffsetWithTopicSwitch&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState,
                                                                                                            <a href="../../../venice/kafka/protocol/TopicSwitch.html" title="class in com.linkedin.venice.kafka.protocol">TopicSwitch</a>&nbsp;topicSwitch,
                                                                                                            <a href="../../../venice/pubsub/api/PubSubTopic.html" title="interface in com.linkedin.venice.pubsub.api">PubSubTopic</a>&nbsp;newSourceTopic,
                                                                                                            java.util.List&lt;java.lang.CharSequence&gt;&nbsp;unreachableBrokerList)</pre>
</li>
</ul>
<a id="startConsumingAsLeader(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>startConsumingAsLeader</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;startConsumingAsLeader&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="StoreIngestionTask.html#startConsumingAsLeader(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">startConsumingAsLeader</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="leaderExecuteTopicSwitch(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,com.linkedin.venice.kafka.protocol.TopicSwitch,com.linkedin.venice.pubsub.api.PubSubTopic)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>leaderExecuteTopicSwitch</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;leaderExecuteTopicSwitch&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState,
                                        <a href="../../../venice/kafka/protocol/TopicSwitch.html" title="class in com.linkedin.venice.kafka.protocol">TopicSwitch</a>&nbsp;topicSwitch,
                                        <a href="../../../venice/pubsub/api/PubSubTopic.html" title="interface in com.linkedin.venice.pubsub.api">PubSubTopic</a>&nbsp;newSourceTopic)</pre>
</li>
</ul>
<a id="syncConsumedUpstreamRTOffsetMapIfNeeded(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,java.util.Map)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>syncConsumedUpstreamRTOffsetMapIfNeeded</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;syncConsumedUpstreamRTOffsetMapIfNeeded&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;pcs,
                                                       java.util.Map&lt;java.lang.String,&#8203;java.lang.Long&gt;&nbsp;upstreamStartOffsetByKafkaURL)</pre>
</li>
</ul>
<a id="waitForLastLeaderPersistFuture(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>waitForLastLeaderPersistFuture</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;waitForLastLeaderPersistFuture&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState,
                                              java.lang.String&nbsp;errorMsg)</pre>
</li>
</ul>
<a id="getTopicPartitionOffsetByKafkaURL(java.lang.CharSequence,com.linkedin.venice.pubsub.api.PubSubTopicPartition,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTopicPartitionOffsetByKafkaURL</h4>
<pre class="methodSignature">protected&nbsp;long&nbsp;getTopicPartitionOffsetByKafkaURL&#8203;(java.lang.CharSequence&nbsp;kafkaURL,
                                                 <a href="../../../venice/pubsub/api/PubSubTopicPartition.html" title="interface in com.linkedin.venice.pubsub.api">PubSubTopicPartition</a>&nbsp;pubSubTopicPartition,
                                                 long&nbsp;rewindStartTimestamp)</pre>
</li>
</ul>
<a id="getConsumptionSourceKafkaAddress(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getConsumptionSourceKafkaAddress</h4>
<pre class="methodSignature">protected&nbsp;java.util.Set&lt;java.lang.String&gt;&nbsp;getConsumptionSourceKafkaAddress&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="StoreIngestionTask.html#getConsumptionSourceKafkaAddress(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">getConsumptionSourceKafkaAddress</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="getRealTimeDataSourceKafkaAddress(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRealTimeDataSourceKafkaAddress</h4>
<pre class="methodSignature">protected&nbsp;java.util.Set&lt;java.lang.String&gt;&nbsp;getRealTimeDataSourceKafkaAddress&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="StoreIngestionTask.html#getRealTimeDataSourceKafkaAddress(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">getRealTimeDataSourceKafkaAddress</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="shouldNewLeaderSwitchToRemoteConsumption(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shouldNewLeaderSwitchToRemoteConsumption</h4>
<pre class="methodSignature">protected&nbsp;boolean&nbsp;shouldNewLeaderSwitchToRemoteConsumption&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</pre>
</li>
</ul>
<a id="shouldProduceToVersionTopic(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shouldProduceToVersionTopic</h4>
<pre class="methodSignature">protected&nbsp;boolean&nbsp;shouldProduceToVersionTopic&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</pre>
<div class="block">For the corresponding partition being tracked in `partitionConsumptionState`, if it's in LEADER state and it's
 not consuming from version topic, it should produce the new message to version topic; besides, if LEADER is
 consuming remotely, it should also produce to local fabric.

 If buffer replay is disable, all replicas will stick to version topic, no one is going to produce any message.</div>
</li>
</ul>
<a id="isLeader(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isLeader</h4>
<pre class="methodSignature">protected&nbsp;boolean&nbsp;isLeader&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</pre>
</li>
</ul>
<a id="processTopicSwitch(com.linkedin.venice.kafka.protocol.ControlMessage,int,long,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>processTopicSwitch</h4>
<pre class="methodSignature">protected&nbsp;boolean&nbsp;processTopicSwitch&#8203;(<a href="../../../venice/kafka/protocol/ControlMessage.html" title="class in com.linkedin.venice.kafka.protocol">ControlMessage</a>&nbsp;controlMessage,
                                     int&nbsp;partition,
                                     long&nbsp;offset,
                                     <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</pre>
<div class="block">Process <a href="../../../venice/kafka/protocol/TopicSwitch.html" title="class in com.linkedin.venice.kafka.protocol"><code>TopicSwitch</code></a> control message at given partition offset for a specific <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer"><code>PartitionConsumptionState</code></a>.
 Return whether we need to execute additional ready-to-serve check after this message is processed.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="StoreIngestionTask.html#processTopicSwitch(com.linkedin.venice.kafka.protocol.ControlMessage,int,long,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">processTopicSwitch</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="syncTopicSwitchToIngestionMetadataService(com.linkedin.venice.kafka.protocol.TopicSwitch,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>syncTopicSwitchToIngestionMetadataService</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;syncTopicSwitchToIngestionMetadataService&#8203;(<a href="../../../venice/kafka/protocol/TopicSwitch.html" title="class in com.linkedin.venice.kafka.protocol">TopicSwitch</a>&nbsp;topicSwitch,
                                                         <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</pre>
</li>
</ul>
<a id="updateOffsetsFromConsumerRecord(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,com.linkedin.venice.pubsub.api.PubSubMessage,com.linkedin.davinci.kafka.consumer.LeaderProducedRecordContext,com.linkedin.davinci.kafka.consumer.LeaderFollowerStoreIngestionTask.UpdateVersionTopicOffset,com.linkedin.davinci.kafka.consumer.LeaderFollowerStoreIngestionTask.UpdateUpstreamTopicOffset,com.linkedin.davinci.kafka.consumer.LeaderFollowerStoreIngestionTask.GetLastKnownUpstreamTopicOffset,java.util.function.Supplier,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>updateOffsetsFromConsumerRecord</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;updateOffsetsFromConsumerRecord&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState,
                                               <a href="../../../venice/pubsub/api/PubSubMessage.html" title="interface in com.linkedin.venice.pubsub.api">PubSubMessage</a>&lt;<a href="../../../venice/message/KafkaKey.html" title="class in com.linkedin.venice.message">KafkaKey</a>,&#8203;<a href="../../../venice/kafka/protocol/KafkaMessageEnvelope.html" title="class in com.linkedin.venice.kafka.protocol">KafkaMessageEnvelope</a>,&#8203;java.lang.Long&gt;&nbsp;consumerRecord,
                                               <a href="LeaderProducedRecordContext.html" title="class in com.linkedin.davinci.kafka.consumer">LeaderProducedRecordContext</a>&nbsp;leaderProducedRecordContext,
                                               com.linkedin.davinci.kafka.consumer.LeaderFollowerStoreIngestionTask.UpdateVersionTopicOffset&nbsp;updateVersionTopicOffsetFunction,
                                               com.linkedin.davinci.kafka.consumer.LeaderFollowerStoreIngestionTask.UpdateUpstreamTopicOffset&nbsp;updateUpstreamTopicOffsetFunction,
                                               com.linkedin.davinci.kafka.consumer.LeaderFollowerStoreIngestionTask.GetLastKnownUpstreamTopicOffset&nbsp;lastKnownUpstreamTopicOffsetSupplier,
                                               java.util.function.Supplier&lt;java.lang.String&gt;&nbsp;sourceKafkaUrlSupplier,
                                               boolean&nbsp;dryRun)</pre>
<div class="block">A helper function to the latest in-memory offsets processed by drainers in <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer"><code>PartitionConsumptionState</code></a>,
 after processing the given <a href="../../../venice/pubsub/api/PubSubMessage.html" title="interface in com.linkedin.venice.pubsub.api"><code>PubSubMessage</code></a>.

 When using this helper function to update the latest in-memory offsets processed by drainers in <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer"><code>PartitionConsumptionState</code></a>:
 "updateVersionTopicOffsetFunction" should try to update the VT offset in <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer"><code>PartitionConsumptionState</code></a>
 "updateRealtimeTopicOffsetFunction" should try to update the latest processed upstream offset map in <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer"><code>PartitionConsumptionState</code></a>

 In LeaderFollowerStoreIngestionTask, "sourceKafkaUrlSupplier" should always return <a href="../../../venice/offsets/OffsetRecord.html#NON_AA_REPLICATION_UPSTREAM_OFFSET_MAP_KEY"><code>OffsetRecord.NON_AA_REPLICATION_UPSTREAM_OFFSET_MAP_KEY</code></a>;
 in ActiveActiveStoreIngestionTask, "sourceKafkaUrlSupplier" should return the actual source Kafka url of the "consumerRecordWrapper"

 Dry-run mode would only check whether the offset rewind is benign or not instead of persisting the processed offset.</div>
</li>
</ul>
<a id="updateOffsetMetadataInOffsetRecord(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>updateOffsetMetadataInOffsetRecord</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;updateOffsetMetadataInOffsetRecord&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="StoreIngestionTask.html#updateOffsetMetadataInOffsetRecord(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">StoreIngestionTask</a></code></span></div>
<div class="block">Sync the metadata about offset in <a href="../../../venice/offsets/OffsetRecord.html" title="class in com.linkedin.venice.offsets"><code>OffsetRecord</code></a>.
 <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer"><code>PartitionConsumptionState</code></a> will pass through some information to <a href="../../../venice/offsets/OffsetRecord.html" title="class in com.linkedin.venice.offsets"><code>OffsetRecord</code></a> for persistence and
 Offset rewind/split brain has been guarded in <a href="StoreIngestionTask.html#updateLatestInMemoryProcessedOffset(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,com.linkedin.venice.pubsub.api.PubSubMessage,com.linkedin.davinci.kafka.consumer.LeaderProducedRecordContext,java.lang.String,boolean)"><code>StoreIngestionTask.updateLatestInMemoryProcessedOffset(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState, com.linkedin.venice.pubsub.api.PubSubMessage&lt;com.linkedin.venice.message.KafkaKey, com.linkedin.venice.kafka.protocol.KafkaMessageEnvelope, java.lang.Long&gt;, com.linkedin.davinci.kafka.consumer.LeaderProducedRecordContext, java.lang.String, boolean)</code></a>.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="StoreIngestionTask.html#updateOffsetMetadataInOffsetRecord(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">updateOffsetMetadataInOffsetRecord</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="updateLatestInMemoryProcessedOffset(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,com.linkedin.venice.pubsub.api.PubSubMessage,com.linkedin.davinci.kafka.consumer.LeaderProducedRecordContext,java.lang.String,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>updateLatestInMemoryProcessedOffset</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;updateLatestInMemoryProcessedOffset&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState,
                                                   <a href="../../../venice/pubsub/api/PubSubMessage.html" title="interface in com.linkedin.venice.pubsub.api">PubSubMessage</a>&lt;<a href="../../../venice/message/KafkaKey.html" title="class in com.linkedin.venice.message">KafkaKey</a>,&#8203;<a href="../../../venice/kafka/protocol/KafkaMessageEnvelope.html" title="class in com.linkedin.venice.kafka.protocol">KafkaMessageEnvelope</a>,&#8203;java.lang.Long&gt;&nbsp;consumerRecordWrapper,
                                                   <a href="LeaderProducedRecordContext.html" title="class in com.linkedin.davinci.kafka.consumer">LeaderProducedRecordContext</a>&nbsp;leaderProducedRecordContext,
                                                   java.lang.String&nbsp;kafkaUrl,
                                                   boolean&nbsp;dryRun)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="StoreIngestionTask.html#updateLatestInMemoryProcessedOffset(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,com.linkedin.venice.pubsub.api.PubSubMessage,com.linkedin.davinci.kafka.consumer.LeaderProducedRecordContext,java.lang.String,boolean)">StoreIngestionTask</a></code></span></div>
<div class="block">Maintain the latest processed offsets by drainers in memory; in most of the time, these offsets are ahead of the
 checkpoint offsets inside <a href="../../../venice/offsets/OffsetRecord.html" title="class in com.linkedin.venice.offsets"><code>OffsetRecord</code></a>. Prior to update the offset in memory, the underlying storage engine
 should have persisted the given record.

 Dry-run mode will only do offset rewind check and it won't update the processed offset.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="StoreIngestionTask.html#updateLatestInMemoryProcessedOffset(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,com.linkedin.venice.pubsub.api.PubSubMessage,com.linkedin.davinci.kafka.consumer.LeaderProducedRecordContext,java.lang.String,boolean)">updateLatestInMemoryProcessedOffset</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="checkAndHandleUpstreamOffsetRewind(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,com.linkedin.venice.pubsub.api.PubSubMessage,long,long,com.linkedin.davinci.kafka.consumer.LeaderFollowerStoreIngestionTask)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkAndHandleUpstreamOffsetRewind</h4>
<pre class="methodSignature">protected static&nbsp;void&nbsp;checkAndHandleUpstreamOffsetRewind&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState,
                                                         <a href="../../../venice/pubsub/api/PubSubMessage.html" title="interface in com.linkedin.venice.pubsub.api">PubSubMessage</a>&lt;<a href="../../../venice/message/KafkaKey.html" title="class in com.linkedin.venice.message">KafkaKey</a>,&#8203;<a href="../../../venice/kafka/protocol/KafkaMessageEnvelope.html" title="class in com.linkedin.venice.kafka.protocol">KafkaMessageEnvelope</a>,&#8203;java.lang.Long&gt;&nbsp;consumerRecord,
                                                         long&nbsp;newUpstreamOffset,
                                                         long&nbsp;previousUpstreamOffset,
                                                         <a href="LeaderFollowerStoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">LeaderFollowerStoreIngestionTask</a>&nbsp;ingestionTask)</pre>
</li>
</ul>
<a id="produceToLocalKafka(com.linkedin.venice.pubsub.api.PubSubMessage,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,com.linkedin.davinci.kafka.consumer.LeaderProducedRecordContext,java.util.function.BiConsumer,int,java.lang.String,int,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>produceToLocalKafka</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;produceToLocalKafka&#8203;(<a href="../../../venice/pubsub/api/PubSubMessage.html" title="interface in com.linkedin.venice.pubsub.api">PubSubMessage</a>&lt;<a href="../../../venice/message/KafkaKey.html" title="class in com.linkedin.venice.message">KafkaKey</a>,&#8203;<a href="../../../venice/kafka/protocol/KafkaMessageEnvelope.html" title="class in com.linkedin.venice.kafka.protocol">KafkaMessageEnvelope</a>,&#8203;java.lang.Long&gt;&nbsp;consumerRecord,
                                   <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState,
                                   <a href="LeaderProducedRecordContext.html" title="class in com.linkedin.davinci.kafka.consumer">LeaderProducedRecordContext</a>&nbsp;leaderProducedRecordContext,
                                   java.util.function.BiConsumer&lt;<a href="../../../venice/writer/ChunkAwareCallback.html" title="interface in com.linkedin.venice.writer">ChunkAwareCallback</a>,&#8203;<a href="../../../venice/writer/LeaderMetadataWrapper.html" title="class in com.linkedin.venice.writer">LeaderMetadataWrapper</a>&gt;&nbsp;produceFunction,
                                   int&nbsp;subPartition,
                                   java.lang.String&nbsp;kafkaUrl,
                                   int&nbsp;kafkaClusterId,
                                   long&nbsp;beforeProcessingRecordTimestampNs)</pre>
</li>
</ul>
<a id="isRealTimeBufferReplayStarted(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isRealTimeBufferReplayStarted</h4>
<pre class="methodSignature">protected&nbsp;boolean&nbsp;isRealTimeBufferReplayStarted&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="StoreIngestionTask.html#isRealTimeBufferReplayStarted(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">isRealTimeBufferReplayStarted</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="measureHybridOffsetLag(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>measureHybridOffsetLag</h4>
<pre class="methodSignature">protected&nbsp;long&nbsp;measureHybridOffsetLag&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState,
                                      boolean&nbsp;shouldLogLag)</pre>
<div class="block">For Leader/Follower state model, we already keep track of the consumption progress in leader, so directly calculate
 the lag with the real-time topic and the leader consumption offset.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="StoreIngestionTask.html#measureHybridOffsetLag(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,boolean)">measureHybridOffsetLag</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="measureRTOffsetLagForMultiRegions(java.util.Set,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>measureRTOffsetLagForMultiRegions</h4>
<pre class="methodSignature">protected&nbsp;long&nbsp;measureRTOffsetLagForMultiRegions&#8203;(java.util.Set&lt;java.lang.String&gt;&nbsp;sourceRealTimeTopicKafkaURLs,
                                                 <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState,
                                                 boolean&nbsp;shouldLogLag)</pre>
</li>
</ul>
<a id="isReadyToServeAnnouncedWithRTLag()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isReadyToServeAnnouncedWithRTLag</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isReadyToServeAnnouncedWithRTLag()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="StoreIngestionTask.html#isReadyToServeAnnouncedWithRTLag()">isReadyToServeAnnouncedWithRTLag</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="reportIfCatchUpVersionTopicOffset(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reportIfCatchUpVersionTopicOffset</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;reportIfCatchUpVersionTopicOffset&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;pcs)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="StoreIngestionTask.html#reportIfCatchUpVersionTopicOffset(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">StoreIngestionTask</a></code></span></div>
<div class="block">Check if the ingestion progress has reached to the end of the version topic. This is currently only
 used <a href="LeaderFollowerStoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer"><code>LeaderFollowerStoreIngestionTask</code></a>.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="StoreIngestionTask.html#reportIfCatchUpVersionTopicOffset(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">reportIfCatchUpVersionTopicOffset</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="shouldProcessRecord(com.linkedin.venice.pubsub.api.PubSubMessage,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shouldProcessRecord</h4>
<pre class="methodSignature">protected&nbsp;boolean&nbsp;shouldProcessRecord&#8203;(<a href="../../../venice/pubsub/api/PubSubMessage.html" title="interface in com.linkedin.venice.pubsub.api">PubSubMessage</a>&lt;<a href="../../../venice/message/KafkaKey.html" title="class in com.linkedin.venice.message">KafkaKey</a>,&#8203;<a href="../../../venice/kafka/protocol/KafkaMessageEnvelope.html" title="class in com.linkedin.venice.kafka.protocol">KafkaMessageEnvelope</a>,&#8203;java.lang.Long&gt;&nbsp;record,
                                      int&nbsp;subPartition)</pre>
<div class="block">For Leader/Follower model, the follower should have the same kind of check as the Online/Offline model;
 for leader, it's possible that it consumers from real-time topic or GF topic.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="StoreIngestionTask.html#shouldProcessRecord(com.linkedin.venice.pubsub.api.PubSubMessage,int)">shouldProcessRecord</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="shouldPersistRecord(com.linkedin.venice.pubsub.api.PubSubMessage,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shouldPersistRecord</h4>
<pre class="methodSignature">protected&nbsp;boolean&nbsp;shouldPersistRecord&#8203;(<a href="../../../venice/pubsub/api/PubSubMessage.html" title="interface in com.linkedin.venice.pubsub.api">PubSubMessage</a>&lt;<a href="../../../venice/message/KafkaKey.html" title="class in com.linkedin.venice.message">KafkaKey</a>,&#8203;<a href="../../../venice/kafka/protocol/KafkaMessageEnvelope.html" title="class in com.linkedin.venice.kafka.protocol">KafkaMessageEnvelope</a>,&#8203;java.lang.Long&gt;&nbsp;record,
                                      <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</pre>
<div class="block">Additional safeguards in Leader/Follower ingestion:
 1. Check whether the incoming messages are from the expected source topics</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="StoreIngestionTask.html#shouldPersistRecord(com.linkedin.venice.pubsub.api.PubSubMessage,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">shouldPersistRecord</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="recordWriterStats(long,long,long,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recordWriterStats</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;recordWriterStats&#8203;(long&nbsp;consumerTimestampMs,
                                 long&nbsp;producerBrokerLatencyMs,
                                 long&nbsp;brokerConsumerLatencyMs,
                                 <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="StoreIngestionTask.html#recordWriterStats(long,long,long,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">recordWriterStats</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="recordProcessedRecordStats(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recordProcessedRecordStats</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;recordProcessedRecordStats&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState,
                                          int&nbsp;processedRecordSize)</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="StoreIngestionTask.html#recordProcessedRecordStats(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,int)">recordProcessedRecordStats</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="isHybridFollower(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isHybridFollower</h4>
<pre class="methodSignature">protected&nbsp;boolean&nbsp;isHybridFollower&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="StoreIngestionTask.html#isHybridFollower(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">isHybridFollower</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="shouldCheckLeaderCompleteStateInFollower()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shouldCheckLeaderCompleteStateInFollower</h4>
<pre class="methodSignature">protected&nbsp;boolean&nbsp;shouldCheckLeaderCompleteStateInFollower()</pre>
<div class="block">For non AA hybrid stores with AGGREGATE DRP, SIT reads from parent RT while the HB is written to the child RTs.
 Once all hybrid stores are either AA for cross colo replication and non AA otherwise, DRP and this extra
 check can also be removed.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="StoreIngestionTask.html#shouldCheckLeaderCompleteStateInFollower()">shouldCheckLeaderCompleteStateInFollower</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="checkAndLogIfLagIsAcceptableForHybridStore(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,long,long,boolean,com.linkedin.davinci.ingestion.LagType,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkAndLogIfLagIsAcceptableForHybridStore</h4>
<pre class="methodSignature">protected&nbsp;boolean&nbsp;checkAndLogIfLagIsAcceptableForHybridStore&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;pcs,
                                                             long&nbsp;lag,
                                                             long&nbsp;threshold,
                                                             boolean&nbsp;shouldLogLag,
                                                             <a href="../../ingestion/LagType.html" title="enum in com.linkedin.davinci.ingestion">LagType</a>&nbsp;lagType,
                                                             long&nbsp;latestConsumedProducerTimestamp)</pre>
<div class="block">Checks whether the lag is acceptable for hybrid stores
 <p>
 If the instance is a hybrid standby or DaVinciClient: Also check if <br>
 1. checkLeaderCompleteStateInFollower feature is enabled based on configs <br>
 2. leaderCompleteStatus has the leader state=completed and <br>
 3. the last update time was within the configured time interval to not use the stale leader state: check
    <code>com.linkedin.venice.ConfigKeys.SERVER_LEADER_COMPLETE_STATE_CHECK_IN_FOLLOWER_VALID_INTERVAL_MS</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="StoreIngestionTask.html#checkAndLogIfLagIsAcceptableForHybridStore(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,long,long,boolean,com.linkedin.davinci.ingestion.LagType,long)">checkAndLogIfLagIsAcceptableForHybridStore</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="getAndUpdateLeaderCompletedState(com.linkedin.venice.message.KafkaKey,com.linkedin.venice.kafka.protocol.KafkaMessageEnvelope,com.linkedin.venice.kafka.protocol.ControlMessage,com.linkedin.venice.pubsub.api.PubSubMessageHeaders,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAndUpdateLeaderCompletedState</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;getAndUpdateLeaderCompletedState&#8203;(<a href="../../../venice/message/KafkaKey.html" title="class in com.linkedin.venice.message">KafkaKey</a>&nbsp;kafkaKey,
                                                <a href="../../../venice/kafka/protocol/KafkaMessageEnvelope.html" title="class in com.linkedin.venice.kafka.protocol">KafkaMessageEnvelope</a>&nbsp;kafkaValue,
                                                <a href="../../../venice/kafka/protocol/ControlMessage.html" title="class in com.linkedin.venice.kafka.protocol">ControlMessage</a>&nbsp;controlMessage,
                                                <a href="../../../venice/pubsub/api/PubSubMessageHeaders.html" title="class in com.linkedin.venice.pubsub.api">PubSubMessageHeaders</a>&nbsp;pubSubMessageHeaders,
                                                <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</pre>
<div class="block">HeartBeat SOS messages carry the leader completion state in the header. This function extracts the leader completion
 state from that header and updates the {@param partitionConsumptionState} accordingly.</div>
</li>
</ul>
<a id="recordHeartbeatReceived(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,com.linkedin.venice.pubsub.api.PubSubMessage,java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recordHeartbeatReceived</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;recordHeartbeatReceived&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState,
                                       <a href="../../../venice/pubsub/api/PubSubMessage.html" title="interface in com.linkedin.venice.pubsub.api">PubSubMessage</a>&lt;<a href="../../../venice/message/KafkaKey.html" title="class in com.linkedin.venice.message">KafkaKey</a>,&#8203;<a href="../../../venice/kafka/protocol/KafkaMessageEnvelope.html" title="class in com.linkedin.venice.kafka.protocol">KafkaMessageEnvelope</a>,&#8203;java.lang.Long&gt;&nbsp;consumerRecord,
                                       java.lang.String&nbsp;kafkaUrl)</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="StoreIngestionTask.html#recordHeartbeatReceived(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,com.linkedin.venice.pubsub.api.PubSubMessage,java.lang.String)">recordHeartbeatReceived</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="delegateConsumerRecord(com.linkedin.venice.pubsub.api.PubSubMessage,int,java.lang.String,int,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>delegateConsumerRecord</h4>
<pre class="methodSignature">protected&nbsp;<a href="StoreIngestionTask.DelegateConsumerRecordResult.html" title="enum in com.linkedin.davinci.kafka.consumer">StoreIngestionTask.DelegateConsumerRecordResult</a>&nbsp;delegateConsumerRecord&#8203;(<a href="../../../venice/pubsub/api/PubSubMessage.html" title="interface in com.linkedin.venice.pubsub.api">PubSubMessage</a>&lt;<a href="../../../venice/message/KafkaKey.html" title="class in com.linkedin.venice.message">KafkaKey</a>,&#8203;<a href="../../../venice/kafka/protocol/KafkaMessageEnvelope.html" title="class in com.linkedin.venice.kafka.protocol">KafkaMessageEnvelope</a>,&#8203;java.lang.Long&gt;&nbsp;consumerRecord,
                                                                                 int&nbsp;subPartition,
                                                                                 java.lang.String&nbsp;kafkaUrl,
                                                                                 int&nbsp;kafkaClusterId,
                                                                                 long&nbsp;beforeProcessingPerRecordTimestampNs,
                                                                                 long&nbsp;beforeProcessingBatchRecordsTimestampMs)</pre>
<div class="block">The goal of this function is to possibly produce the incoming kafka message consumed from local VT, remote VT, RT or SR topic to
 local VT if needed. It's decided based on the function output of <a href="#shouldProduceToVersionTopic(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)"><code>shouldProduceToVersionTopic(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)</code></a> and message type.
 It also perform any necessary additional computation operation such as for write-compute/update message.
 It returns a boolean indicating if it was produced to kafka or not.

 This function should be called as one of the first steps in processing pipeline for all messages consumed from any kafka topic.

 The caller of this function should only process this {@param consumerRecord} further if the return is
 <a href="StoreIngestionTask.DelegateConsumerRecordResult.html#QUEUED_TO_DRAINER"><code>StoreIngestionTask.DelegateConsumerRecordResult.QUEUED_TO_DRAINER</code></a>.

 This function assumes <a href="#shouldProcessRecord(com.linkedin.venice.pubsub.api.PubSubMessage,int)"><code>shouldProcessRecord(PubSubMessage, int)</code></a> has been called which happens in
 <a href="StoreIngestionTask.html#produceToStoreBufferServiceOrKafka(java.lang.Iterable,com.linkedin.venice.pubsub.api.PubSubTopicPartition,java.lang.String,int)"><code>StoreIngestionTask.produceToStoreBufferServiceOrKafka(Iterable, PubSubTopicPartition, String, int)</code></a>
 before calling this and the it was decided that this record needs to be processed. It does not perform any
 validation check on the PartitionConsumptionState object to keep the goal of the function simple and not overload.

 Also DIV validation is done here if the message is received from RT topic. For more info please see
 please see StoreIngestionTask#internalProcessConsumerRecord(PubSubMessage, PartitionConsumptionState, LeaderProducedRecordContext, int, String, long)

 This function may modify the original record in KME and it is unsafe to use the payload from KME directly after this function.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="StoreIngestionTask.html#delegateConsumerRecord(com.linkedin.venice.pubsub.api.PubSubMessage,int,java.lang.String,int,long,long)">delegateConsumerRecord</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="StoreIngestionTask.DelegateConsumerRecordResult.html" title="enum in com.linkedin.davinci.kafka.consumer"><code>StoreIngestionTask.DelegateConsumerRecordResult</code></a> indicating what to do with the record</dd>
</dl>
</li>
</ul>
<a id="waitForAllMessageToBeProcessedFromTopicPartition(com.linkedin.venice.pubsub.api.PubSubTopicPartition,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>waitForAllMessageToBeProcessedFromTopicPartition</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;waitForAllMessageToBeProcessedFromTopicPartition&#8203;(<a href="../../../venice/pubsub/api/PubSubTopicPartition.html" title="interface in com.linkedin.venice.pubsub.api">PubSubTopicPartition</a>&nbsp;topicPartition,
                                                                <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)
                                                         throws java.lang.InterruptedException</pre>
<div class="block">Besides draining messages in the drainer queue, wait for the last producer future.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="StoreIngestionTask.html#waitForAllMessageToBeProcessedFromTopicPartition(com.linkedin.venice.pubsub.api.PubSubTopicPartition,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">waitForAllMessageToBeProcessedFromTopicPartition</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>topicPartition</code> - for which to wait</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a id="getBatchReplicationLag()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getBatchReplicationLag</h4>
<pre class="methodSignature">public&nbsp;long&nbsp;getBatchReplicationLag()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="StoreIngestionTask.html#getBatchReplicationLag()">getBatchReplicationLag</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="getLeaderOffsetLag()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLeaderOffsetLag</h4>
<pre class="methodSignature">public&nbsp;long&nbsp;getLeaderOffsetLag()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="StoreIngestionTask.html#getLeaderOffsetLag()">getLeaderOffsetLag</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="getBatchLeaderOffsetLag()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getBatchLeaderOffsetLag</h4>
<pre class="methodSignature">public&nbsp;long&nbsp;getBatchLeaderOffsetLag()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="StoreIngestionTask.html#getBatchLeaderOffsetLag()">getBatchLeaderOffsetLag</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="getHybridLeaderOffsetLag()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getHybridLeaderOffsetLag</h4>
<pre class="methodSignature">public&nbsp;long&nbsp;getHybridLeaderOffsetLag()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="StoreIngestionTask.html#getHybridLeaderOffsetLag()">getHybridLeaderOffsetLag</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="getLatestPersistedUpstreamOffsetForHybridOffsetLagMeasurement(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLatestPersistedUpstreamOffsetForHybridOffsetLagMeasurement</h4>
<pre class="methodSignature">protected&nbsp;long&nbsp;getLatestPersistedUpstreamOffsetForHybridOffsetLagMeasurement&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;pcs,
                                                                             java.lang.String&nbsp;ignoredUpstreamKafkaUrl)</pre>
<div class="block">For L/F or NR, there is only one entry in upstreamOffsetMap whose key is NON_AA_REPLICATION_UPSTREAM_OFFSET_MAP_KEY.
 Return the value of the entry.</div>
</li>
</ul>
<a id="getLatestConsumedUpstreamOffsetForHybridOffsetLagMeasurement(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLatestConsumedUpstreamOffsetForHybridOffsetLagMeasurement</h4>
<pre class="methodSignature">protected&nbsp;long&nbsp;getLatestConsumedUpstreamOffsetForHybridOffsetLagMeasurement&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;pcs,
                                                                            java.lang.String&nbsp;ignoredKafkaUrl)</pre>
<div class="block">For regular L/F stores without A/A enabled, there is always only one real-time source.</div>
</li>
</ul>
<a id="updateLatestInMemoryLeaderConsumedRTOffset(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,java.lang.String,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>updateLatestInMemoryLeaderConsumedRTOffset</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;updateLatestInMemoryLeaderConsumedRTOffset&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;pcs,
                                                          java.lang.String&nbsp;ignoredKafkaUrl,
                                                          long&nbsp;offset)</pre>
</li>
</ul>
<a id="getFollowerOffsetLag()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFollowerOffsetLag</h4>
<pre class="methodSignature">public&nbsp;long&nbsp;getFollowerOffsetLag()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="StoreIngestionTask.html#getFollowerOffsetLag()">StoreIngestionTask</a></code></span></div>
<div class="block">Measure the offset lag between follower and leader</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="StoreIngestionTask.html#getFollowerOffsetLag()">getFollowerOffsetLag</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="getBatchFollowerOffsetLag()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getBatchFollowerOffsetLag</h4>
<pre class="methodSignature">public&nbsp;long&nbsp;getBatchFollowerOffsetLag()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="StoreIngestionTask.html#getBatchFollowerOffsetLag()">getBatchFollowerOffsetLag</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="getHybridFollowerOffsetLag()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getHybridFollowerOffsetLag</h4>
<pre class="methodSignature">public&nbsp;long&nbsp;getHybridFollowerOffsetLag()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="StoreIngestionTask.html#getHybridFollowerOffsetLag()">getHybridFollowerOffsetLag</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="getRegionHybridOffsetLag(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRegionHybridOffsetLag</h4>
<pre class="methodSignature">public&nbsp;long&nbsp;getRegionHybridOffsetLag&#8203;(int&nbsp;regionId)</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="StoreIngestionTask.html#getRegionHybridOffsetLag(int)">getRegionHybridOffsetLag</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="consumerUnSubscribeAllTopics(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>consumerUnSubscribeAllTopics</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;consumerUnSubscribeAllTopics&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</pre>
<div class="block">Unsubscribe from all the topics being consumed for the partition in partitionConsumptionState</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="StoreIngestionTask.html#consumerUnSubscribeAllTopics(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">consumerUnSubscribeAllTopics</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="getWriteComputeErrorCode()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getWriteComputeErrorCode</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;getWriteComputeErrorCode()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="StoreIngestionTask.html#getWriteComputeErrorCode()">getWriteComputeErrorCode</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="updateLeaderTopicOnFollower(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>updateLeaderTopicOnFollower</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;updateLeaderTopicOnFollower&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="StoreIngestionTask.html#updateLeaderTopicOnFollower(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">updateLeaderTopicOnFollower</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="getSubPartitionId(byte[],com.linkedin.venice.pubsub.api.PubSubTopicPartition)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSubPartitionId</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;getSubPartitionId&#8203;(byte[]&nbsp;key,
                                <a href="../../../venice/pubsub/api/PubSubTopicPartition.html" title="interface in com.linkedin.venice.pubsub.api">PubSubTopicPartition</a>&nbsp;topicPartition)</pre>
</li>
</ul>
<a id="maybeCompressData(int,java.nio.ByteBuffer,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>maybeCompressData</h4>
<pre class="methodSignature">protected&nbsp;java.nio.ByteBuffer&nbsp;maybeCompressData&#8203;(int&nbsp;partition,
                                                java.nio.ByteBuffer&nbsp;data,
                                                <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</pre>
<div class="block">Compresses data in a bytebuffer when consuming from rt as a leader node and compression is enabled for the store
 version for which we're consuming data.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>partition</code> - which partition we're acting on so as to determine the PartitionConsumptionState</dd>
<dd><code>data</code> - the data that we might compress</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a bytebuffer that's either the original bytebuffer or a new one depending on if we compressed it.</dd>
</dl>
</li>
</ul>
<a id="shouldCompressData(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shouldCompressData</h4>
<pre class="methodSignature">protected&nbsp;boolean&nbsp;shouldCompressData&#8203;(<a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</pre>
</li>
</ul>
<a id="processMessageAndMaybeProduceToKafka(com.linkedin.venice.pubsub.api.PubSubMessage,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,int,java.lang.String,int,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>processMessageAndMaybeProduceToKafka</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;processMessageAndMaybeProduceToKafka&#8203;(<a href="../../../venice/pubsub/api/PubSubMessage.html" title="interface in com.linkedin.venice.pubsub.api">PubSubMessage</a>&lt;<a href="../../../venice/message/KafkaKey.html" title="class in com.linkedin.venice.message">KafkaKey</a>,&#8203;<a href="../../../venice/kafka/protocol/KafkaMessageEnvelope.html" title="class in com.linkedin.venice.kafka.protocol">KafkaMessageEnvelope</a>,&#8203;java.lang.Long&gt;&nbsp;consumerRecord,
                                                    <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState,
                                                    int&nbsp;subPartition,
                                                    java.lang.String&nbsp;kafkaUrl,
                                                    int&nbsp;kafkaClusterId,
                                                    long&nbsp;beforeProcessingRecordTimestampNs,
                                                    long&nbsp;currentTimeForMetricsMs)</pre>
</li>
</ul>
<a id="measureRTOffsetLagForSingleRegion(java.lang.String,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>measureRTOffsetLagForSingleRegion</h4>
<pre class="methodSignature">protected&nbsp;long&nbsp;measureRTOffsetLagForSingleRegion&#8203;(java.lang.String&nbsp;sourceRealTimeTopicKafkaURL,
                                                 <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;pcs,
                                                 boolean&nbsp;shouldLog)</pre>
<div class="block">This method fetches/calculates latest leader persisted offset and last offset in RT topic. The method relies on
 <a href="#getLatestPersistedUpstreamOffsetForHybridOffsetLagMeasurement(com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,java.lang.String)"><code>getLatestPersistedUpstreamOffsetForHybridOffsetLagMeasurement(PartitionConsumptionState, String)</code></a> to fetch
 latest leader persisted offset for different data replication policy.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the lag (lastOffsetInRealTimeTopic - latestPersistedLeaderOffset)</dd>
</dl>
</li>
</ul>
<a id="processVersionSwapMessage(com.linkedin.venice.kafka.protocol.ControlMessage,int,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>processVersionSwapMessage</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;processVersionSwapMessage&#8203;(<a href="../../../venice/kafka/protocol/ControlMessage.html" title="class in com.linkedin.venice.kafka.protocol">ControlMessage</a>&nbsp;controlMessage,
                                         int&nbsp;partition,
                                         <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="StoreIngestionTask.html#processVersionSwapMessage(com.linkedin.venice.kafka.protocol.ControlMessage,int,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">StoreIngestionTask</a></code></span></div>
<div class="block">This isn't really used for ingestion outside of A/A, so we NoOp here and rely on the actual implementation in
  <a href="ActiveActiveStoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer"><code>ActiveActiveStoreIngestionTask</code></a></div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="StoreIngestionTask.html#processVersionSwapMessage(com.linkedin.venice.kafka.protocol.ControlMessage,int,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">processVersionSwapMessage</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
</dl>
</li>
</ul>
<a id="createProducerCallback(com.linkedin.venice.pubsub.api.PubSubMessage,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState,com.linkedin.davinci.kafka.consumer.LeaderProducedRecordContext,int,java.lang.String,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createProducerCallback</h4>
<pre class="methodSignature">protected&nbsp;<a href="LeaderProducerCallback.html" title="class in com.linkedin.davinci.kafka.consumer">LeaderProducerCallback</a>&nbsp;createProducerCallback&#8203;(<a href="../../../venice/pubsub/api/PubSubMessage.html" title="interface in com.linkedin.venice.pubsub.api">PubSubMessage</a>&lt;<a href="../../../venice/message/KafkaKey.html" title="class in com.linkedin.venice.message">KafkaKey</a>,&#8203;<a href="../../../venice/kafka/protocol/KafkaMessageEnvelope.html" title="class in com.linkedin.venice.kafka.protocol">KafkaMessageEnvelope</a>,&#8203;java.lang.Long&gt;&nbsp;consumerRecord,
                                                        <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;partitionConsumptionState,
                                                        <a href="LeaderProducedRecordContext.html" title="class in com.linkedin.davinci.kafka.consumer">LeaderProducedRecordContext</a>&nbsp;leaderProducedRecordContext,
                                                        int&nbsp;subPartition,
                                                        java.lang.String&nbsp;kafkaUrl,
                                                        long&nbsp;beforeProcessingRecordTimestampNs)</pre>
</li>
</ul>
<a id="getVeniceWriter()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getVeniceWriter</h4>
<pre class="methodSignature">protected&nbsp;<a href="../../../venice/utils/lazy/Lazy.html" title="interface in com.linkedin.venice.utils.lazy">Lazy</a>&lt;<a href="../../../venice/writer/VeniceWriter.html" title="class in com.linkedin.venice.writer">VeniceWriter</a>&lt;byte[],&#8203;byte[],&#8203;byte[]&gt;&gt;&nbsp;getVeniceWriter()</pre>
</li>
</ul>
<a id="addPartitionConsumptionState(java.lang.Integer,com.linkedin.davinci.kafka.consumer.PartitionConsumptionState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addPartitionConsumptionState</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;addPartitionConsumptionState&#8203;(java.lang.Integer&nbsp;partition,
                                            <a href="PartitionConsumptionState.html" title="class in com.linkedin.davinci.kafka.consumer">PartitionConsumptionState</a>&nbsp;pcs)</pre>
</li>
</ul>
<a id="maybeSendIngestionHeartbeat()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>maybeSendIngestionHeartbeat</h4>
<pre class="methodSignature">protected&nbsp;java.util.Set&lt;java.lang.String&gt;&nbsp;maybeSendIngestionHeartbeat()</pre>
<div class="block">For hybrid stores only, the leader periodically writes a special SOS message to the RT topic with the following properties: <br>
 1. Special key: This key contains constant bytes, allowing for compaction. <br>
 2. Fixed/known producer GUID: This GUID is dedicated to heartbeats and prevents DIV from breaking. <br>
 3. Special segment: This segment never contains data, eliminating the need for an EOS message. <br>
 <p>
 Upon consuming the SOS message, the leader writes it to its local VT. Once the drainer processes the record, the leader updates
 its latest processed upstream RT topic offset. At this point, the offset reflects the correct position, regardless of trailing
 CMs or skippable data records due to DCR.
 <p>
 This heartbeat message does not send a leader completion header. This results in having the leader completion states only in VTs and not
 in the RT, avoiding the need to differentiate between heartbeats from leaders of different versions (backup/current/future) and colos.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="StoreIngestionTask.html#maybeSendIngestionHeartbeat()">maybeSendIngestionHeartbeat</a></code>&nbsp;in class&nbsp;<code><a href="StoreIngestionTask.html" title="class in com.linkedin.davinci.kafka.consumer">StoreIngestionTask</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the set of partitions that failed to send heartbeat (used for tests)</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
